[
	{
		"text_input": "Create a scene with two dots connected by an orange line, with braces and annotations indicating the horizontal distance and a mathematical expression.",
		"output": "from manim import *\n\nclass BraceAnnotation(Scene):\n    def construct(self):\n        dot = Dot([-2, -1, 0])\n        dot2 = Dot([2, 1, 0])\n        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)\n        b1 = Brace(line)\n        b1text = b1.get_text(\"Horizontal distance\")\n        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())\n        b2text = b2.get_tex(\"x-x_1\")\n        self.add(line, dot, dot2, b1, b2, b1text, b2text)"
	},
	{
		"text_input": "Create a scene with a number plane, a dot at the origin, an arrow from the origin to (2, 2), and labels for the origin and tip of the arrow.",
		"output": "from manim import *\n\nclass VectorArrow(Scene):\n    def construct(self):\n        dot = Dot(ORIGIN)\n        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)\n        numberplane = NumberPlane()\n        origin_text = Text('(0, 0)').next_to(dot, DOWN)\n        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)\n        self.add(numberplane, dot, arrow, origin_text, tip_text)"
	},
	
	{
		"text_input": "Create a scene with a 256x256 gradient image and a green surrounding rectangle.",
		"output": "from manim import *\n\nclass GradientImageFromArray(Scene):\n    def construct(self):\n        n = 256\n        imageArray = np.uint8(\n            [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]\n        )\n        image = ImageMobject(imageArray).scale(2)\n        image.background_rectangle = SurroundingRectangle(image, GREEN)\n        self.add(image, image.background_rectangle)"
	},
	{
		"text_input": "Create a scene demonstrating boolean operations (intersection, union, exclusion, difference) with two overlapping ellipses, each with different colors and text annotations for each operation.",
		"output": "from manim import *\n\nclass BooleanOperations(Scene):\n    def construct(self):\n        ellipse1 = Ellipse(\n            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10\n        ).move_to(LEFT)\n        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)\n        bool_ops_text = MarkupText(\"<u>Boolean Operation</u>\").next_to(ellipse1, UP * 3)\n        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)\n        self.play(FadeIn(ellipse_group))\n\n        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)\n        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))\n        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)\n        self.play(FadeIn(intersection_text))\n\n        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)\n        union_text = Text(\"Union\", font_size=23)\n        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))\n        union_text.next_to(u, UP)\n        self.play(FadeIn(union_text))\n\n        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)\n        exclusion_text = Text(\"Exclusion\", font_size=23)\n        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))\n        exclusion_text.next_to(e, UP)\n        self.play(FadeIn(exclusion_text))\n\n        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)\n        difference_text = Text(\"Difference\", font_size=23)\n        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))\n        difference_text.next_to(d, UP)\n        self.play(FadeIn(difference_text))"
	},
	
	{
		"text_input": "Create a scene with a point moving on shapes including a circle and a line, with various animations such as growing a circle, transforming a dot, moving a dot along a path, and rotating a dot.",
		"output": "from manim import *\n\nclass PointMovingOnShapes(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        dot = Dot()\n        dot2 = dot.copy().shift(RIGHT)\n        self.add(dot)\n\n        line = Line([3, 0, 0], [5, 0, 0])\n        self.add(line)\n\n        self.play(GrowFromCenter(circle))\n        self.play(Transform(dot, dot2))\n        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)\n        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)\n        self.wait()"
	},
	
	{
		"text_input": "Create a scene with a blue square that moves left, changes color to orange, scales down to 30%, and rotates by 0.4 radians.",
		"output": "from manim import *\n\nclass MovingAround(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1)\n\n        self.play(square.animate.shift(LEFT))\n        self.play(square.animate.set_fill(ORANGE))\n        self.play(square.animate.scale(0.3))\n        self.play(square.animate.rotate(0.4))"
	},
	
	{
		"text_input": "Create a scene where an angle between two lines changes dynamically, with initial setup and animations adjusting the angle's value and appearance.",
		"output": "from manim import *\n\nclass MovingAngle(Scene):\n    def construct(self):\n        rotation_center = LEFT\n\n        theta_tracker = ValueTracker(110)\n        line1 = Line(LEFT, RIGHT)\n        line_moving = Line(LEFT, RIGHT)\n        line_ref = line_moving.copy()\n        line_moving.rotate(\n            theta_tracker.get_value() * DEGREES, about_point=rotation_center\n        )\n        a = Angle(line1, line_moving, radius=0.5, other_angle=False)\n        tex = MathTex(r\"\\theta\").move_to(\n            Angle(\n                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n            ).point_from_proportion(0.5)\n        )\n\n        self.add(line1, line_moving, a, tex)\n        self.wait()\n\n        line_moving.add_updater(\n            lambda x: x.become(line_ref.copy()).rotate(\n                theta_tracker.get_value() * DEGREES, about_point=rotation_center\n            )\n        )\n\n        a.add_updater(\n            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))\n        )\n        tex.add_updater(\n            lambda x: x.move_to(\n                Angle(\n                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n                ).point_from_proportion(0.5)\n            )\n        )\n\n        self.play(theta_tracker.animate.set_value(40))\n        self.play(theta_tracker.animate.increment_value(140))\n        self.play(tex.animate.set_color(RED), run_time=0.5)\n        self.play(theta_tracker.animate.set_value(350))"
	},
	{
		"text_input": "Create a scene with two dots initially arranged horizontally (blue and green), connected by a red line. Use ValueTrackers to animate the horizontal position of the blue dot and the vertical position of the green dot.",
		"output": "from manim import *\n\nclass MovingDots(Scene):\n    def construct(self):\n        d1, d2 = Dot(color=BLUE), Dot(color=GREEN)\n        dg = VGroup(d1, d2).arrange(RIGHT, buff=1)\n        l1 = Line(d1.get_center(), d2.get_center()).set_color(RED)\n        x = ValueTracker(0)\n        y = ValueTracker(0)\n        d1.add_updater(lambda z: z.set_x(x.get_value()))\n        d2.add_updater(lambda z: z.set_y(y.get_value()))\n        l1.add_updater(lambda z: z.become(Line(d1.get_center(), d2.get_center())))\n        self.add(d1, d2, l1)\n        self.play(x.animate.set_value(5))\n        self.play(y.animate.set_value(4))\n        self.wait()"
	},
	
	{
		"text_input": "Create a scene with a group of dots initially arranged horizontally, scaled to 1.4 times their original size. Move the group to a destination dot located at coordinates (4, 3) with a yellow color.",
		"output": "from manim import *\n\nclass MovingGroupToDestination(Scene):\n    def construct(self):\n        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)\n        dest = Dot([4, 3, 0], color=YELLOW)\n        self.add(group, dest)\n        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))\n        self.wait(0.5)"
	},
	
	{
		"text_input": "Create a scene where a mathematical expression is displayed using MathTex, showing the product rule formula. Surround the terms 'f(x)d/dx g(x)' and 'g(x)d/dx f(x)' with frame boxes sequentially.",
		"output": "from manim import *\n\nclass MovingFrameBox(Scene):\n    def construct(self):\n        text = MathTex(\n            \"\\frac{d}{dx}f(x)g(x)=\", \"f(x)\\frac{d}{dx}g(x)\", \"+\", \"g(x)\\frac{d}{dx}f(x)\"\n        )\n        self.play(Write(text))\n        framebox1 = SurroundingRectangle(text[1], buff=0.1)\n        framebox2 = SurroundingRectangle(text[3], buff=0.1)\n        self.play(Create(framebox1))\n        self.wait()\n        self.play(ReplacementTransform(framebox1, framebox2))\n        self.wait()"
	},
	
	{
		"text_input": "Create a scene with a white reference line and a yellow line that rotates continuously clockwise for 2 seconds, then counterclockwise for 2 seconds, and finally waits for 0.5 seconds.",
		"output": "from manim import *\n\nclass RotationUpdater(Scene):\n    def construct(self):\n        def updater_forth(mobj, dt):\n            mobj.rotate_about_origin(dt)\n        def updater_back(mobj, dt):\n            mobj.rotate_about_origin(-dt)\n        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)\n        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)\n        line_moving.add_updater(updater_forth)\n        self.add(line_reference, line_moving)\n        self.wait(2)\n        line_moving.remove_updater(updater_forth)\n        line_moving.add_updater(updater_back)\n        self.wait(2)\n        line_moving.remove_updater(updater_back)\n        self.wait(0.5)"
	},
	
	{
		"text_input": "Create a scene where a dot leaves a trace as it moves. Initially, the dot rotates 180 degrees around the point (1, 0, 0) over 2 seconds. Then, it moves up and left sequentially, each move taking 1 second.",
		"output": "from manim import *\n\nclass PointWithTrace(Scene):\n    def construct(self):\n        path = VMobject()\n        dot = Dot()\n        path.set_points_as_corners([dot.get_center(), dot.get_center()])\n        def update_path(path):\n            previous_path = path.copy()\n            previous_path.add_points_as_corners([dot.get_center()])\n            path.become(previous_path)\n        path.add_updater(update_path)\n        self.add(path, dot)\n        self.play(Rotating(dot, radians=PI, about_point=RIGHT, run_time=2))\n        self.wait()\n        self.play(dot.animate.shift(UP))\n        self.play(dot.animate.shift(LEFT))\n        self.wait()"
	},
	
	{
		"text_input": "Create a scene that plots the sine and cosine functions on a set of axes ranging from x = -10 to x = 10, with y-axis ranging from -1.5 to 1.5. Customize the x-axis to include ticks and labels for every 2 units. Include labels for each function and a vertical line at x = 2π with a corresponding label.",
		"output": "from manim import *\n\nclass SinAndCosFunctionPlot(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-10, 10.3, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=10,\n            axis_config={\"color\": GREEN},\n            x_axis_config={\n                \"numbers_to_include\": np.arange(-10, 10.01, 2),\n                \"numbers_with_elongated_ticks\": np.arange(-10, 10.01, 2),\n            },\n            tips=False,\n        )\n        axes_labels = axes.get_axis_labels()\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)\n\n        sin_label = axes.get_graph_label(\n            sin_graph, \"\\sin(x)\", x_val=-10, direction=UP / 2\n        )\n        cos_label = axes.get_graph_label(cos_graph, label=\"\\cos(x)\")\n\n        vert_line = axes.get_vertical_line(\n            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line\n        )\n        line_label = axes.get_graph_label(\n            cos_graph, \"x=2\\pi\", x_val=TAU, direction=UR, color=WHITE\n        )\n\n        plot = VGroup(axes, sin_graph, cos_graph, vert_line)\n        labels = VGroup(axes_labels, sin_label, cos_label, line_label)\n        self.add(plot, labels)"
	},
	
	{
		"text_input": "Create a scene that includes an x-y graph with x ranging from 0 to 10 and y ranging from 0 to 100 (in steps of 10), excluding the axes' tips. Plot a function f(x) = 2*(x-5)^2 in maroon color. Display a dot that moves along the minimum point of the function f(x) as x varies over its range from 0 to 10.",
		"output": "from manim import *\nimport numpy as np\n\nclass ArgMinExample(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10], y_range=[0, 100, 10], axis_config={\"include_tip\": False}\n        )\n        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        t = ValueTracker(0)\n\n        def func(x):\n            return 2 * (x - 5) ** 2\n\n        graph = ax.plot(func, color=MAROON)\n\n        x_space = np.linspace(*ax.x_range[:2], 200)\n        minimum_index = func(x_space).argmin()\n        initial_point = [ax.coords_to_point(x_space[minimum_index], func(x_space[minimum_index]))]\n        dot = Dot(point=initial_point)\n\n        dot.add_updater(lambda x: x.move_to(ax.c2p(x_space[minimum_index], func(x_space[minimum_index]))))\n\n        self.add(ax, labels, graph, dot)\n        self.play(t.animate.set_value(x_space[minimum_index]))\n        self.wait()"
	},
	
	{
		"text_input": "Create a scene that plots two curves on a set of axes. Curve 1 is a downward-opening parabola from x=0 to x=4, colored blue. Curve 2 is a quadratic curve from x=0 to x=4, colored green. Include vertical lines at x=2 and x=3 in yellow color for curve 1. Also, display Riemann rectangles for curve 1 in the x-range [0.3, 0.6] with blue color and opacity 0.5, and show the area between curve 2 and curve 1 bounded from x=2 to x=3 with grey color and opacity 0.5.",
		"output": "from manim import *\n\nclass GraphAreaPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            x_axis_config={\"numbers_to_include\": [2, 3]},\n            tips=False,\n        )\n\n        labels = ax.get_axis_labels()\n\n        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)\n        curve_2 = ax.plot(\n            lambda x: 0.8 * x ** 2 - 3 * x + 4,\n            x_range=[0, 4],\n            color=GREEN_B,\n        )\n\n        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)\n        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)\n\n        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)\n        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)\n\n        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)"
	},
	
	{
		"text_input": "Create a scene that displays an axes with x ranging from 0 to 10 and y ranging from 0 to 10, excluding axis tips. Plot a curve y=k/x in yellow color where k=25, from x=k/10 to x=10. Include a polygon that dynamically updates to enclose the area under the curve between x=0 and the current value of t, filled with blue color and yellow stroke. Initially, place a dot at the point (5, 2) on the axes, which updates its position as t changes.",
		"output": "from manim import *\n\nclass PolygonOnAxes(Scene):\n    def get_rectangle_corners(self, bottom_left, top_right):\n        return [\n            (top_right[0], top_right[1]),\n            (bottom_left[0], top_right[1]),\n            (bottom_left[0], bottom_left[1]),\n            (top_right[0], bottom_left[1]),\n        ]\n\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            x_length=6,\n            y_length=6,\n            axis_config={\"include_tip\": False},\n        )\n\n        t = ValueTracker(5)\n        k = 25\n\n        graph = ax.plot(\n            lambda x: k / x,\n            color=YELLOW_D,\n            x_range=[k / 10, 10.0, 0.01],\n            use_smoothing=False,\n        )\n\n        def get_rectangle():\n            polygon = Polygon(\n                *[ax.c2p(*i) for i in self.get_rectangle_corners((0, 0), (t.get_value(), k / t.get_value())))\n            )\n            polygon.stroke_width = 1\n            polygon.set_fill(BLUE, opacity=0.5)\n            polygon.set_stroke(YELLOW_B)\n            return polygon\n\n        polygon = always_redraw(get_rectangle)\n\n        dot = Dot()\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))\n        dot.set_z_index(10)\n\n        self.add(ax, graph, dot)\n        self.play(Create(polygon))\n        self.play(t.animate.set_value(10))\n        self.play(t.animate.set_value(k / 10))\n        self.play(t.animate.set_value(5))"
	},
	
	{
		"text_input": "Create a scene that displays an axes with x-axis labeled as ΔQ and y-axis labeled as T[°C]. Set the x-axis range from 0 to 40 with ticks at every 5 units, and the y-axis range from -8 to 32 with ticks at every 5 units. Display a line graph connecting the points (0, 20), (8, 0), (38, 0), and (39, -5) on the axes.",
		"output": "from manim import *\nimport numpy as np\n\nclass HeatDiagramPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 40, 5],\n            y_range=[-8, 32, 5],\n            x_length=9,\n            y_length=6,\n            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},\n            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},\n            tips=False,\n        )\n        labels = ax.get_axis_labels(\n            x_label=Tex(\"$\\Delta Q$\"), y_label=Tex(\"T[°C]\")\n        )\n\n        x_vals = [0, 8, 38, 39]\n        y_vals = [20, 0, 0, -5]\n        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)\n\n        self.add(ax, labels, graph)"
	},
	
	{
		"text_input": "Create a scene where a camera follows a dot moving along a sine curve plotted on axes. Initially, scale the camera frame to 0.5 and position it at the location of the moving dot. Use the color blue for the sine curve. Display three dots: one moving dot following the sine curve, and two stationary dots at the minimum and maximum of the sine curve.",
		"output": "from manim import *\n\nclass FollowingGraphCamera(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        # create the axes and the curve\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])\n\n        # create dots based on the graph\n        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n\n        self.add(ax, graph, dot_1, dot_2, moving_dot)\n        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))\n\n        def update_curve(mob):\n            mob.move_to(moving_dot.get_center())\n\n        self.camera.frame.add_updater(update_curve)\n        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))\n        self.camera.frame.remove_updater(update_curve)\n\n        self.play(Restore(self.camera.frame))"
	},
	
	{
		"text_input": "Create a scene where a dot is positioned at the upper-left corner (UL * 2). Display an image represented by a 2x4 array of pixel values. Define 'Frame' and 'Zoomed camera' texts colored in purple and red, respectively. Initially, show the image and dot. When zoomed, display the zoomed camera and frame with appropriate shifts. Scale down both the frame and zoomed display by a factor of 0.5 in the x-direction, 1.5 in the y-direction, and leave z unchanged. Finally, scale up the zoomed display by a factor of 2, shift the frame 2.5 units downward, and smoothly zoom out the zoomed display.",
		"output": "from manim import *\n\n\nclass MovingZoomedSceneAround(ZoomedScene):\n    # contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(\n            self,\n            zoom_factor=0.3,\n            zoomed_display_height=1,\n            zoomed_display_width=6,\n            image_frame_stroke_width=20,\n            zoomed_camera_config={\n                \"default_frame_stroke_width\": 3,\n            },\n            **kwargs\n        )\n\n    def construct(self):\n        dot = Dot().shift(UL * 2)\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        frame_text = Text(\"Frame\", color=PURPLE, font_size=67)\n        zoomed_camera_text = Text(\"Zoomed camera\", color=RED, font_size=67)\n\n        self.add(image, dot)\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n\n        frame.move_to(dot)\n        frame.set_color(PURPLE)\n        zoomed_display_frame.set_color(RED)\n        zoomed_display.shift(DOWN)\n\n        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)\n        self.add_foreground_mobject(zd_rect)\n\n        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))\n\n        frame_text.next_to(frame, DOWN)\n\n        self.play(Create(frame), FadeIn(frame_text, shift=UP))\n        self.activate_zooming()\n\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)\n        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)\n        self.play(FadeIn(zoomed_camera_text, shift=UP))\n        scale_factor = [0.5, 1.5, 0]\n        self.play(\n            frame.animate.scale(scale_factor),\n            zoomed_display.animate.scale(scale_factor),\n            FadeOut(zoomed_camera_text),\n            FadeOut(frame_text)\n        )\n        self.wait()\n        self.play(ScaleInPlace(zoomed_display, 2))\n        self.wait()\n        self.play(frame.animate.shift(2.5 * DOWN))\n        self.wait()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))\n        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))\n        self.wait()"
	},
	
	{
		"text_input": "Create a 3D scene with axes and a 3D text object displaying 'This is a 3D text'. Orient the camera with a phi angle of 75 degrees and a theta angle of -45 degrees. Add the text as a fixed-in-frame Mobject to the upper-left corner (UL).",
		"output": "from manim import *\n\nclass FixedInFrameMObjectTest(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        text3d = Text(\"This is a 3D text\")\n        self.add_fixed_in_frame_mobjects(text3d)\n        text3d.to_corner(UL)\n        self.add(axes)\n        self.wait()"
	},
	
	{
		"text_input": "Create a 3D scene with axes and a spherical surface defined by the parametric equations for a sphere with radius 1.5. Set the surface color using a checkerboard pattern with colors RED_D and RED_E. Move the light source to 3 units in the direction of the IN axis (3*IN). Orient the camera with a phi angle of 75 degrees and a theta angle of 30 degrees.",
		"output": "from manim import *\n\n\nclass ThreeDLightSourcePosition(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        sphere = Surface(\n            lambda u, v: np.array([\n                1.5 * np.cos(u) * np.cos(v),\n                1.5 * np.cos(u) * np.sin(v),\n                1.5 * np.sin(u)\n            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],\n            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)\n        )\n        self.renderer.camera.light_source.move_to(3*IN)  # changes the source of the light\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, sphere)"
	},
	
	{
		"text_input": "Create a 3D scene with axes and a circle object. Set the camera orientation with a phi angle of 75 degrees and a theta angle of 30 degrees. Begin rotating the camera around the scene at a rate of 0.1 radians per second. After waiting for the rotation, stop the ambient camera rotation. Then, move the camera to the same orientation again (phi=75 degrees, theta=30 degrees) and wait for the scene to play out.",
		"output": "from manim import *\n\nclass ThreeDCameraRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle = Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle, axes)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.wait()"
	},
	
	{
		"text_input": "Create a 3D scene with axes and a circle object. Set the camera orientation with a phi angle of 75 degrees and a theta angle of 30 degrees. Begin rotating the camera around an illusionary axis at a rate of 2 radians per second. After waiting for half of PI seconds (PI/2), stop the illusionary camera rotation.",
		"output": "from manim import *\n\nclass ThreeDCameraIllusionRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle = Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle, axes)\n        self.begin_3dillusion_camera_rotation(rate=2)\n        self.wait(PI/2)\n        self.stop_3dillusion_camera_rotation()"
	},
	
	{
		"text_input": "Create a 3D scene with axes and a Gaussian surface plot. Define the function `param_gauss` which generates points on the surface based on Gaussian distribution. Set the camera orientation with a phi angle of 75 degrees and a theta angle of -30 degrees. Use a resolution factor of 24 for smoother surface rendering. Scale the Gaussian plane by a factor of 2 about the origin. Set the surface style with a green stroke color, fill opacity of 1, and checkerboard fill using orange and blue colors with 0.5 opacity.",
		"output": "from manim import *\nimport numpy as np\n\nclass ThreeDSurfacePlot(ThreeDScene):\n    def construct(self):\n        resolution_fa = 24\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-30 * DEGREES)\n\n        def param_gauss(u, v):\n            x = u\n            y = v\n            sigma, mu = 0.4, [0.0, 0.0]\n            d = np.linalg.norm(np.array([x - mu[0], y - mu[1]]))\n            z = np.exp(-(d ** 2 / (2.0 * sigma ** 2)))\n            return np.array([x, y, z])\n\n        gauss_plane = Surface(\n            param_gauss,\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[-2, +2],\n            u_range=[-2, +2]\n        )\n\n        gauss_plane.scale(2, about_point=ORIGIN)\n        gauss_plane.set_style(fill_opacity=1, stroke_color=GREEN)\n        gauss_plane.set_fill_by_checkerboard(ORANGE, BLUE, opacity=0.5)\n        axes = ThreeDAxes()\n        self.add(axes, gauss_plane)"
	},
	
	{
		"text_input": "Create an opening scene in Manim with the following steps:\n1. Display a title 'This is some LaTeX' and a mathematical expression using MathTex: '$\\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}$'. Arrange them vertically.\n2. Play the animation to write the title and fade in the mathematical expression.\n3. Transform the title to 'That was a transform' and simultaneously fade out the mathematical expression.\n4. Introduce a NumberPlane grid with the title 'This is a grid' above it. Fade out the original title and fade in the grid title while creating the grid with a run time of 3 seconds and a lag ratio of 0.1.\n5. Transform the grid title to 'That was a non-linear function \\ applied to the grid'. Apply a non-linear transformation to the grid where each point is shifted by [sin(y), sin(x), 0] over 3 seconds.",
		"output": "from manim import *\n\n\nclass OpeningManim(Scene):\n    def construct(self):\n        title = Tex(r\"This is some \\LaTeX\")\n        basel = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}\")\n        VGroup(title, basel).arrange(DOWN)\n        self.play(\n            Write(title),\n            FadeIn(basel, shift=DOWN),\n        )\n        self.wait()\n\n        transform_title = Tex(\"That was a transform\")\n        transform_title.to_corner(UP + LEFT)\n        self.play(\n            Transform(title, transform_title),\n            LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]),\n        )\n        self.wait()\n\n        grid = NumberPlane()\n        grid_title = Tex(\"This is a grid\", font_size=72)\n        grid_title.move_to(transform_title)\n\n        self.add(grid, grid_title)  # Make sure title is on top of grid\n        self.play(\n            FadeOut(title),\n            FadeIn(grid_title, shift=UP),\n            Create(grid, run_time=3, lag_ratio=0.1),\n        )\n        self.wait()\n\n        grid_transform_title = Tex(\n            r\"That was a non-linear function \\\\ applied to the grid\"\n        )\n        grid_transform_title.move_to(grid_title, UL)\n        grid.prepare_for_nonlinear_transform()\n        self.play(\n            grid.animate.apply_function(\n                lambda p: p\n                          + np.array(\n                    [\n                        np.sin(p[1]),\n                        np.sin(p[0]),\n                        0,\n                    ]\n                )\n            ),\n            run_time=3,\n        )\n        self.wait()\n        self.play(Transform(grid_title, grid_transform_title))\n        self.wait()"
	},
	
	{
		"text_input": "Create a scene 'SineCurveUnitCircle' that shows the following:\n1. Display axes with labels for points: 'pi', '2 pi', '3 pi', and '4 pi' on the x-axis.\n2. Show a unit circle centered at (-4, 0, 0).\n3. Animate a yellow dot moving around the circumference of the circle at a rate of 0.25.\n4. Draw a blue line from the origin to the yellow dot, a yellow dashed line from the yellow dot to a point on the x-axis, and a yellow curve tracing the y-coordinate of the yellow dot as it moves along the circle. The curve starts at (-3, 0, 0) and moves horizontally to the right.",
		"output": "from manim import *\n\nclass SineCurveUnitCircle(Scene):\n    # contributed by heejin_park, https://infograph.tistory.com/230\n    def construct(self):\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n\n    def show_axis(self):\n        x_start = np.array([-6,0,0])\n        x_end = np.array([6,0,0])\n\n        y_start = np.array([-4,-2,0])\n        y_end = np.array([-4,2,0])\n\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n\n        self.origin_point = np.array([-4,0,0])\n        self.curve_start = np.array([-3,0,0])\n\n    def add_x_labels(self):\n        x_labels = [\n            MathTex(\"\\pi\"), MathTex(\"2 \\pi\"),\n            MathTex(\"3 \\pi\"), MathTex(\"4 \\pi\"),\n        ]\n\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n\n        dot = Dot(radius=0.08, color=YELLOW)\n        dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += (dt * rate)\n            # print(self.t_offset)\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )\n\n\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start,self.curve_start))\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)\n            self.curve.add(new_line)\n\n            return self.curve\n\n        dot.add_updater(go_around_circle)\n\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n\n        self.add(dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n\n        dot.remove_updater(go_around_circle)"
	},
	
	
	
	
	
	
	
	
	
	
	{
		"text_input": "Create a scene 'LagRatios' that demonstrates the use of lag_ratios in Manim animations. The scene should:\n1. Create four groups of dots arranged horizontally.\n2. Display text labels above each group indicating the lag_ratio used for animation.\n3. Animate each group with different lag_ratios simultaneously, shifting them downwards.\n4. Apply a lag_ratio of 0.1 recursively to the nested subobjects of the groups, animating them upward.",
		"output": "from manim import *\n\nclass LagRatios(Scene):\n    def construct(self):\n        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n        # Create dot groups\n        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n        self.add(groups)\n\n        # Label groups\n        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n        for group, ratio in zip(groups, ratios):\n            self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n        #Animate groups with different lag_ratios\n        self.play(AnimationGroup(*[\n            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n            for group, ratio in zip(groups, ratios)\n        ]))\n\n        # lag_ratio also works recursively on nested submobjects:\n        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
	},
	{
		"text_input": "Create a scene 'AnimatedBoundaryExample' that demonstrates the AnimatedBoundary class in Manim. The scene should:\n1. Display the text 'So shiny!'.\n2. Add an AnimatedBoundary around the text with colors cycling through RED, GREEN, and BLUE at a cycle_rate of 3.\n3. Wait for 2 seconds after the animation.",
		"output": "from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        text = Text(\"So shiny!\")\n        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],\n                                    cycle_rate=3)\n        self.add(text, boundary)\n        self.wait(2)"
	},
	{
		"text_input": "Create a scene in Manim that demonstrates a rolling circle with a traced path.",
		"output": "from manim import *\n\nclass TracedPathExample(Scene):\n    def construct(self):\n        circ = Circle(color=RED).shift(4*LEFT)\n        dot = Dot(color=RED).move_to(circ.get_start())\n        rolling_circle = VGroup(circ, dot)\n        trace = TracedPath(circ.get_start)\n        rolling_circle.add_updater(lambda m: m.rotate(-0.3))\n        self.add(trace, rolling_circle)\n        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)"
	},
	{
		"text_input": "Create a Manim scene demonstrating a dot leaving a dissipating path behind it.",
		"output": "from manim import *\n\nclass DissipatingPathExample(Scene):\n    def construct(self):\n        a = Dot(RIGHT * 2)\n        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])\n        self.add(a, b)\n        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))\n        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene demonstrating the use of MathTex and Tex to render the mathematical expression $\\xrightarrow{x^6y^8}$ with both MathTex and Tex.",
		"output": "from manim import *\n\nclass MathTeXDemo(Scene):\n    def construct(self):\n        rtarrow0 = MathTex(r\"\\xrightarrow{x^6y^8}\", font_size=96)\n        rtarrow1 = Tex(r\"$\\xrightarrow{x^6y^8}$\", font_size=96)\n\n        self.add(VGroup(rtarrow0, rtarrow1).arrange(DOWN))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the use of LaggedStart to animate three dots moving horizontally, with a lag_ratio of 0.25.",
		"output": "from manim import *\n\nclass LaggedStartExample(Scene):\n    def construct(self):\n        title = Text(\"lag_ratio = 0.25\").to_edge(UP)\n\n        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)\n        dot2 = Dot(point=LEFT * 2, radius=0.16)\n        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)\n        line_25 = DashedLine(\n            start=LEFT + UP * 2,\n            end=LEFT + DOWN * 2,\n            color=RED\n        )\n        label = Text(\"25%\", font_size=24).next_to(line_25, UP)\n        self.add(title, dot1, dot2, dot3, line_25, label)\n\n        self.play(LaggedStart(\n            dot1.animate.shift(RIGHT * 4),\n            dot2.animate.shift(RIGHT * 4),\n            dot3.animate.shift(RIGHT * 4),\n            lag_ratio=0.25,\n            run_time=4\n        ))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the use of LaggedStartMap to animate a grid of dots and a title with a yellow ripple effect, using a lag_ratio of 0.1 and there_and_back rate_func.",
		"output": "from manim import *\n\nclass LaggedStartMapExample(Scene):\n    def construct(self):\n        title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)\n        dots = VGroup(\n            *[Dot(radius=0.16) for _ in range(35)]\n            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)\n        self.add(dots, title)\n\n        # Animate yellow ripple effect\n        for mob in dots, title:\n            self.play(LaggedStartMap(\n                ApplyMethod, mob,\n                lambda m : (m.set_color, YELLOW),\n                lag_ratio = 0.1,\n                rate_func = there_and_back,\n                run_time = 2\n            ))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the use of Succession to animate a sequence of dots moving in a square-like succession, starting from a square arrangement.",
		"output": "from manim import *\n\nclass SuccessionExample(Scene):\n    def construct(self):\n        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)\n        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)\n        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)\n        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)\n        self.add(dot1, dot2, dot3, dot4)\n\n        self.play(Succession(\n            dot1.animate.move_to(dot2),\n            dot2.animate.move_to(dot3),\n            dot3.animate.move_to(dot4),\n            dot4.animate.move_to(dot1)\n        ))"
	},
	{
		"text_input": "Create a Manim scene that uses the Create animation to incrementally reveal a square.",
		"output": "from manim import *\n\nclass CreateScene(Scene):\n    def construct(self):\n        self.play(Create(Square()))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the DrawBorderThenFill animation to draw the border first and then fill a square with orange color.",
		"output": "from manim import *\n\nclass ShowDrawBorderThenFill(Scene):\n    def construct(self):\n        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the ShowIncreasingSubsets animation to sequentially show one submobject at a time, leaving all previous ones displayed on screen.",
		"output": "from manim import *\n\nclass ShowIncreasingSubsetsScene(Scene):\n    def construct(self):\n        p = VGroup(Dot(), Square(), Triangle())\n        self.add(p)\n        self.play(ShowIncreasingSubsets(p))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene demonstrating the SpiralIn animation with a MathTex symbol scaled by a factor of 7, a green circle shifted to the left, and a blue square shifted upward.",
		"output": "from manim import *\n\nclass SpiralInExample(Scene):\n    def construct(self):\n        pi = MathTex(r\"\\pi\").scale(7)\n        pi.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)\n        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)\n        shapes = VGroup(pi, circle, square)\n        self.play(SpiralIn(shapes))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the Uncreate animation with a Square.",
		"output": "from manim import *\n\nclass ShowUncreate(Scene):\n    def construct(self):\n        self.play(Uncreate(Square()))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the Unwrite animation with a Text object 'Alice and Bob'.",
		"output": "from manim import *\n\nclass UnwriteReverseTrue(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the Unwrite animation with a Text object 'Alice and Bob', starting from the first submobject.",
		"output": "from manim import *\n\nclass UnwriteReverseFalse(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text, reverse=False))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the Write animation with a Text object 'Hello' with font size 144.",
		"output": "from manim import *\n\nclass ShowWrite(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144)))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the Write animation with a Text object 'Hello' with font size 144, starting from the last submobject first and without removing the object after animation.",
		"output": "from manim import *\n\nclass ShowWriteReversed(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the FadeIn animation with a Dot and a Text object 'FadeIn with shift or target_position and scale'. Use FadeIn to animate each part of the text with different parameters such as shift, target_position, and scale.",
		"output": "from manim import *\n\nclass FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeIn with \", \"shift \", \" or target\\\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeIn(tex[0]),\n            FadeIn(tex[1], shift=DOWN),\n            FadeIn(tex[2], target_position=dot),\n            FadeIn(tex[3], scale=1.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the FadeOut animation with a Dot and a Text object 'FadeOut with shift or target_position and scale'. Use FadeOut to animate each part of the text with different parameters such as shift, target_position, and scale.",
		"output": "from manim import *\n\nclass FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeOut with \", \"shift \", \" or target\\\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeOut(tex[0]),\n            FadeOut(tex[1], shift=DOWN),\n            FadeOut(tex[2], target_position=dot),\n            FadeOut(tex[3], scale=0.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the GrowArrow animation. Use two Arrow objects: one that grows from 2*LEFT to 2*RIGHT, and another that grows from 2*DOWN+2*RIGHT to 2*UP+2*LEFT. Apply the GrowArrow animation to each arrow, specifying a different point_color for the second arrow as RED.",
		"output": "from manim import *\n\nclass GrowArrowExample(Scene):\n    def construct(self):\n        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DOWN + 2 * RIGHT, 2 * UP + 2 * LEFT)]\n        VGroup(*arrows).set_x(0).arrange(buff=2)\n        self.play(GrowArrow(arrows[0]))\n        self.play(GrowArrow(arrows[1], point_color=RED))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the GrowFromCenter animation. Use two Square objects. Apply the GrowFromCenter animation to the first square without specifying a point_color, and to the second square with point_color set to RED.",
		"output": "from manim import *\n\nclass GrowFromCenterExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(2)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(GrowFromCenter(squares[0]))\n        self.play(GrowFromCenter(squares[1], point_color=RED))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the GrowFromEdge animation. Use four Square objects. Apply the GrowFromEdge animation to each square using the following directions: DOWN, RIGHT, UR (Upper Right), and UP. For the fourth square, set point_color to RED.",
		"output": "from manim import *\n\nclass GrowFromEdgeExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(GrowFromEdge(squares[2], UR))\n        self.play(GrowFromEdge(squares[3], UP, point_color=RED))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the GrowFromPoint animation. Add a Dot object at position 3 * UR with color GREEN. Create four Square objects and arrange them horizontally with a buffer of 1 unit. Use GrowFromPoint to animate each square as follows: (1) from the origin, (2) from the point [-2, 2, 0], (3) from the point [3, -2, 0] with color RED, and (4) from the Dot object created earlier using its position and color.",
		"output": "from manim import *\n\nclass GrowFromPointExample(Scene):\n    def construct(self):\n        dot = Dot(3 * UR, color=GREEN)\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.add(dot)\n        self.play(GrowFromPoint(squares[0], ORIGIN))\n        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))\n        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))\n        self.play(GrowFromPoint(squares[3], dot, dot.get_color()))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the SpinInFromNothing animation. Create three Square objects and arrange them horizontally with a buffer of 2 units. Use SpinInFromNothing to animate each square as follows: (1) without specifying angle or point_color, (2) with an angle of 2 * PI for one full spin before fully introduced, and (3) with point_color set to RED.",
		"output": "from manim import *\n\nclass SpinInFromNothingExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(3)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(SpinInFromNothing(squares[0]))\n        self.play(SpinInFromNothing(squares[1], angle=2 * PI))\n        self.play(SpinInFromNothing(squares[2], point_color=RED))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the ApplyWave animation. Use a scaled Tex object with the text 'WaveWaveWaveWaveWave'. Play the ApplyWave animation three times on the Tex object with the following configurations: (1) default settings, (2) direction set to RIGHT, time_width set to 0.5, and amplitude set to 0.3, (3) rate_func set to linear and ripples set to 4.",
		"output": "from manim import *\n\nclass ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)\n        self.play(ApplyWave(tex))\n        self.play(ApplyWave(\n            tex,\n            direction=RIGHT,\n            time_width=0.5,\n            amplitude=0.3\n        ))\n        self.play(ApplyWave(\n            tex,\n            rate_func=linear,\n            ripples=4\n        ))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the Circumscribe animation. Use a scaled Tex object with the text 'Circum-scribe'. Play the Circumscribe animation five times on the Tex object with the following configurations: (1) default settings, (2) shape set to Circle, (3) fade_out set to True, (4) time_width set to 2, (5) shape set to Circle and fade_in set to True.",
		"output": "from manim import *\n\nclass UsingCircumscribe(Scene):\n    def construct(self):\n        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n        self.add(lbl)\n        self.play(Circumscribe(lbl))\n        self.play(Circumscribe(lbl, Circle))\n        self.play(Circumscribe(lbl, fade_out=True))\n        self.play(Circumscribe(lbl, time_width=2))\n        self.play(Circumscribe(lbl, Circle, True))"
	},
	{
		"text_input": "Create a Manim scene demonstrating the Flash animation. Add a yellow Dot shifted downward along with the text 'Flash the dot below:'. Apply the Flash animation once on the Dot.",
		"output": "from manim import *\n\nclass UsingFlash(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Flash the dot below:\"), dot)\n        self.play(Flash(dot))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where a red Circle with radius 2 is displayed. Apply the Flash animation to the Circle with parameters: line_length=1, num_lines=30, flash_radius=radius+SMALL_BUFF, time_width=0.3, run_time=2, and rate_func=rush_from.",
		"output": "from manim import *\n\nclass FlashOnCircle(Scene):\n    def construct(self):\n        radius = 2\n        circle = Circle(radius)\n        self.add(circle)\n        self.play(Flash(\n            circle, line_length=1,\n            num_lines=30, color=RED,\n            flash_radius=radius+SMALL_BUFF,\n            time_width=0.3, run_time=2,\n            rate_func = rush_from\n        ))"
	},
	{
		"text_input": "Create a Manim scene where a yellow Dot shifted downwards is displayed. Apply the FocusOn animation to the Dot with parameters: opacity=0.5, color=YELLOW, and run_time=2.",
		"output": "from manim import *\n\nclass UsingFocusOn(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Focusing on the dot below:\"), dot)\n        self.play(FocusOn(dot, opacity=0.5, color=YELLOW, run_time=2))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where a scaled-up and recolored 'Indicate' Tex object is displayed. Use the Indicate animation with parameters: scale_factor=2, color=BLUE.",
		"output": "from manim import *\n\nclass UsingIndicate(Scene):\n    def construct(self):\n        tex = Tex(\"Indicate\").scale(3)\n        self.play(Indicate(tex, scale_factor=2, color=BLUE))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where a regular pentagon (5-sided polygon) is shown with different time_width values for the passing flash animation. Use values: 0.2, 0.5, 1, and 2 for time_width in each animation instance. Display the corresponding value of time_width as a label during each animation.",
		"output": "from manim import *\n\nclass TimeWidthValues(Scene):\n    def construct(self):\n        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)\n        lbl = VMobject()\n        self.add(p, lbl)\n        p = p.copy().set_color(BLUE)\n        for time_width in [0.2, 0.5, 1, 2]:\n            lbl.become(Tex(r\"\\texttt{time_width={{%.1f}}}\" % time_width))\n            self.play(ShowPassingFlash(\n                p.copy().set_color(BLUE),\n                run_time=2,\n                time_width=time_width\n            ))"
	},
	{
		"text_input": "Create a Manim scene where a Text 'Wiggle' is displayed and wiggled with the following parameters: scale_value=1.2, rotation_angle=PI/6, n_wiggles=3. Display the Text initially and apply the Wiggle animation to it.",
		"output": "from manim import *\n\nclass ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"Wiggle\").scale(3)\n        self.add(tex)\n        self.play(Wiggle(\n            tex,\n            scale_value=1.2,\n            rotation_angle=PI/6,\n            n_wiggles=3\n        ))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where a Dot 'd1' starts at the left edge of the screen and moves along a Line 'l1' from left to right. Display the Dot and Line initially. Use linear rate function for the movement.",
		"output": "from manim import *\n\nclass MoveAlongPathExample(Scene):\n    def construct(self):\n        d1 = Dot().set_color(ORANGE)\n        l1 = Line(LEFT, RIGHT)\n        self.add(d1, l1)\n        self.play(MoveAlongPath(d1, l1), rate_func=linear)\n"
	},
	{
		"text_input": "Create a Manim scene where a Square rotates 360 degrees (2*PI radians) around its center. Display the Square initially shifted up by 2 units. Use a linear rate function for the rotation.",
		"output": "from manim import *\n\nclass UsingRotate(Scene):\n    def construct(self):\n        square1 = Square(side_length=0.5).shift(UP * 2)\n        square2 = Square(side_length=0.5)\n        self.play(\n            Rotate(square1, angle=2*PI, about_point=ORIGIN, rate_func=linear),\n            Rotate(square2, angle=2*PI, rate_func=linear),\n        )\n"
	},
	{
		"text_input": "Create a Manim scene where a Circle with radius 4, colored TEAL_A, is broadcasted from its center. Use the default number of mobjects (5), initial opacity (1), final opacity (0), and initial width (0.0). Set the run time to 3 seconds and the lag ratio to 0.2.",
		"output": "from manim import *\n\nclass BroadcastExample(Scene):\n    def construct(self):\n        circle = Circle(radius=4, color=TEAL_A)\n        self.play(Broadcast(circle, run_time=3, lag_ratio=0.2))\n"
	},
	{
		"text_input": "Create a Manim scene where two dots, `a` and `b`, are initially positioned at `LEFT * 4` and `RIGHT * 4` respectively. Use `ChangeSpeed` to modify the speed of an `AnimationGroup` where dot `a` moves to `RIGHT * 8` and dot `b` moves to `LEFT * 8`. Use a speedinfo dictionary to set the speed factors at percentages 0.3 (1x speed), 0.4 and 0.6 (0.1x speed), and 1 (1x speed). Apply a linear rate function to the animation.",
		"output": "from manim import *\n\nclass SpeedModifierExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        b = Dot().shift(RIGHT * 4)\n        self.add(a, b)\n        self.play(\n            ChangeSpeed(\n                AnimationGroup(\n                    a.animate(run_time=1).shift(RIGHT * 8),\n                    b.animate(run_time=1).shift(LEFT * 8),\n                ),\n                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                rate_func=linear,\n            )\n        )"
	},
	{
		"text_input": "Create a Manim scene where a dot `a` is initially positioned at `LEFT * 4`. Add an updater to `a` using `ChangeSpeed` to shift it to the right by `RIGHT * 4` over 2 seconds. Use a speedinfo dictionary to modify the speed factors at percentages 0.4 (1x speed), 0.5 and 0.8 (0.2x speed), and 1 (1x speed). Ensure that the updater is affected by the speed changes.",
		"output": "from manim import *\n\nclass SpeedModifierUpdaterExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.play(\n            ChangeSpeed(\n                Wait(2),\n                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},\n                affects_speed_updaters=True,\n            )\n        )"
	},
	{
		"text_input": "Create a Manim scene where a dot `a` is initially positioned at `LEFT * 4`. Add an updater to `a` using `ChangeSpeed` to continuously shift it to the right by `RIGHT * 4` over time. Use a speedinfo dictionary to set the speed factor to 0 at 100% of the animation duration. Ensure that the updater is affected by the speed changes.",
		"output": "from manim import *\n\nclass SpeedModifierUpdaterExample2(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.wait()\n        self.play(\n            ChangeSpeed(\n                Wait(),\n                speedinfo={1: 0},\n                affects_speed_updaters=True,\n            )\n        )"
	},
	{
		"text_input": "Create a Manim scene where a text `Hello World!` and a `NumberPlane` are both transformed using the matrix [[1, 1], [0, 2/3]].",
		"output": "from manim import *\n\nclass ApplyMatrixExample(Scene):\n    def construct(self):\n        matrix = [[1, 1], [0, 2/3]]\n        self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane()))"
	},
	{
		"text_input": "Create a Manim scene where a `Square` mobject is warped using a pointwise function that applies the complex exponential function to each point of the square.",
		"output": "from manim import *\n\nclass WarpSquare(Scene):\n    def construct(self):\n        square = Square()\n        self.play(\n            ApplyPointwiseFunction(\n                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square\n            )\n        )\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where two dots `dl` and `dr` are initially positioned at `2*LEFT` and `2*RIGHT` respectively. Also, create two squares `sl` and `sr`. Arrange `dl` and `sl` vertically downward shifted by `2*LEFT`, and `dr` and `sr` vertically downward shifted by `2*RIGHT`. Use `ClockwiseTransform` to transform `dl` into `sl` in a clockwise oriented arc, and use `Transform` to transform `dr` into `sr`.",
		"output": "from manim import *\n\nclass ClockwiseExample(Scene):\n    def construct(self):\n        dl, dr = Dot(), Dot()\n        sl, sr = Square(), Square()\n\n        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)\n        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)\n\n        self.add(dl, dr)\n        self.wait()\n        self.play(\n            ClockwiseTransform(dl, sl),\n            Transform(dr, sr)\n        )\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where two sets of decimal numbers `c_transform` and `transform` are displayed, each with two DecimalNumber objects representing values (e.g., 3.141 and 1.618). Use `CounterclockwiseTransform` to transform the first number in `c_transform` into the second number, and use `Transform` to transform the first number in `transform` into the second number.",
		"output": "from manim import *\n\nclass CounterclockwiseTransform_vs_Transform(Scene):\n    def construct(self):\n        # set up the numbers\n        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))\n        text_1 = Text(\"CounterclockwiseTransform\", color=RED)\n        c_transform.add(text_1)\n\n        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(c_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        c_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs move in clockwise direction for ClockwiseTransform()\n        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))\n\n        # The mobs move straight up for Transform()\n        self.play(Transform(transform[0], transform[1]))"
	},
	{
		"text_input": "Create a Manim scene where a VGroup named `group` contains four mobjects: Square, Circle, Triangle, and Star, arranged horizontally using `arrange(RIGHT)`. Use `CyclicReplace` to cyclically replace the mobjects in `group`, causing each mobject to take the place of the next one in a loop.",
		"output": "from manim import *\n\nclass CyclicReplaceExample(Scene):\n    def construct(self):\n        group = VGroup(Square(), Circle(), Triangle(), Star())\n        group.arrange(RIGHT)\n        self.add(group)\n\n        for _ in range(4):\n            self.play(CyclicReplace(*group))"
	},
	{
		"text_input": "Create a Manim scene where a Text object saying 'Hello World!' fades to the color red using `FadeToColor` animation.",
		"output": "from manim import *\n\nclass FadeToColorExample(Scene):\n    def construct(self):\n        self.play(FadeToColor(Text('Hello World!'), color=RED))"
	},
	{
		"text_input": "Create a Manim scene where three rectangles are initially arranged vertically on the left side, and three circles are arranged vertically on the right side. Use `FadeTransform` to animate each rectangle fading into its corresponding circle. For the first rectangle to circle transition, enable stretching of the circle. For the second transition, disable stretching and match the length of the circle in the x-direction to the rectangle. For the third transition, disable stretching and match the length of the circle in the y-direction to the rectangle.",
		"output": "from manim import *\n\nclass DifferentFadeTransforms(Scene):\n    def construct(self):\n        starts = [Rectangle(width=4, height=1) for _ in range(3)]\n        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)\n        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]\n        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)\n\n        self.play(*[FadeIn(s) for s in starts])\n        self.play(\n            FadeTransform(starts[0], targets[0], stretch=True),\n            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),\n            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)\n        )\n\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects])"
	},
	{
		"text_input": "Create a Manim scene where two VGroups are defined: `src` containing a Square and a Circle shifted to the left and up, and `target` containing a Circle and a Triangle shifted to the right and down. Use `FadeTransform` to animate `src` into `target`, and `FadeTransformPieces` to animate a copy of `src` into a copy of `target`. Fade in both `src` and its copy before applying the animations.",
		"output": "from manim import *\n\nclass FadeTransformSubmobjects(Scene):\n    def construct(self):\n        src = VGroup(Square(), Circle().shift(LEFT + UP))\n        src.shift(3*LEFT + 2*UP)\n        src_copy = src.copy().shift(4*DOWN)\n\n        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))\n        target.shift(3*RIGHT + 2*UP)\n        target_copy = target.copy().shift(4*DOWN)\n\n        self.play(FadeIn(src), FadeIn(src_copy))\n        self.play(\n            FadeTransform(src, target),\n            FadeTransformPieces(src_copy, target_copy)\n        )\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects])"
	},
	{
		"text_input": "Create a Manim scene where a Circle `c` is defined. Use `generate_target()` to create a modified version of `c` with a green fill, reduced opacity, shifted position, and scaled size. Play the `MoveToTarget` animation to transform `c` into its modified target version.",
		"output": "from manim import *\n\nclass MoveToTargetExample(Scene):\n    def construct(self):\n        c = Circle()\n\n        c.generate_target()\n        c.target.set_fill(color=GREEN, opacity=0.5)\n        c.target.shift(2*RIGHT + UP).scale(0.5)\n\n        self.add(c)\n        self.play(MoveToTarget(c))"
	},
	{
		"text_input": "Create a Manim scene where two sets of Integer mobjects `r_transform` and `transform` are defined. Use `ReplacementTransform` to animate `r_transform` elements replacing each other successively without leaving any mobject behind. Then use `Transform` to animate `transform` elements, where the mobjects linger after each transformation.",
		"output": "from manim import *\n\nclass ReplacementTransformOrTransform(Scene):\n    def construct(self):\n        # set up the numbers\n        r_transform = VGroup(*[Integer(i) for i in range(1,4)])\n        text_1 = Text(\"ReplacementTransform\", color=RED)\n        r_transform.add(text_1)\n\n        transform = VGroup(*[Integer(i) for i in range(4,7)])\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(r_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        r_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs replace each other and none are left behind\n        self.play(ReplacementTransform(r_transform[0], r_transform[1]))\n        self.play(ReplacementTransform(r_transform[1], r_transform[2]))\n\n        # The mobs linger after the Transform()\n        self.play(Transform(transform[0], transform[1]))\n        self.play(Transform(transform[1], transform[2]))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where a Square `s` is defined and its state is saved using `save_state()`. Use `FadeIn` to animate the square appearing, then perform multiple transformations on it using chained `animate` methods to change its color, opacity, position, and scale. Finally, use `Restore` to animate `s` back to its last saved state over a run_time of 2 seconds.",
		"output": "from manim import *\n\nclass RestoreExample(Scene):\n    def construct(self):\n        s = Square()\n        s.save_state()\n        self.play(FadeIn(s))\n        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n        self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n        self.wait()\n        self.play(Restore(s), run_time=2)"
	},
	{
		"text_input": "Create a Manim scene where a Text object 'Hello World!' is scaled by a factor of 2 using `ScaleInPlace`.",
		"output": "from manim import *\n\nclass ScaleInPlaceExample(Scene):\n    def construct(self):\n        self.play(ScaleInPlace(Text(\"Hello World!\"), 2))"
	},
	{
		"text_input": "Create a Manim scene where a Text object 'Hello World!' shrinks to the center using `ShrinkToCenter`.",
		"output": "from manim import *\n\nclass ShrinkToCenterExample(Scene):\n    def construct(self):\n        self.play(ShrinkToCenter(Text(\"Hello World!\")))"
	},
	{
		"text_input": "Create a Manim scene where a Circle object moves from the left to the right in multiple transformations, each following a different path arc defined by angles ranging from -90° to 270°. Display the angles next to each Circle during the animation.",
		"output": "from manim import *\n\n# Define a function to create the arc path\n\ndef make_arc_path(start, end, arc_angle):\n    points = []\n    p_fn = path_along_arc(arc_angle)\n    for alpha in range(0, 11):\n        points.append(p_fn(start, end, alpha / 10.0))\n    path = VMobject(stroke_color=YELLOW)\n    path.set_points_smoothly(points)\n    return path\n\n\nclass TransformPathArc(Scene):\n    def construct(self):\n        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n        examples = [-90, 0, 30, 90, 180, 270]\n        anims = []\n        for idx, angle in enumerate(examples):\n            left_c = left.copy().shift((3 - idx) * UP)\n            left_c.fill_color = colors[idx]\n            right_c = left_c.copy().shift(4 * RIGHT)\n            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                     arc_angle=angle * DEGREES)\n            desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)\n            self.add(\n                path_arc.set_z_index(1),\n                desc.set_z_index(2),\n                left_c.set_z_index(3),\n            )\n            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n        self.play(*anims, run_time=2)\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene where two Text objects, `src` and `tar`, initially display 'the morse code' and 'here come dots' respectively. Use `TransformMatchingShapes` to transform `src` into `tar` with a path arc of `PI/2`.",
		"output": "from manim import *\n\nclass Anagram(Scene):\n    def construct(self):\n        src = Text(\"the morse code\")\n        tar = Text(\"here come dots\")\n        self.play(Write(src))\n        self.wait(0.5)\n        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))\n        self.wait(0.5)"
	},
	{
		"text_input": "Create a Manim scene where there are three MathTex objects representing variables 'a^2', 'b^2', and 'c^2' arranged in a row. Additionally, have two MathTex equations `eq1` and `eq2` displayed. Use `TransformMatchingTex` to transform `eq1` and `variables` into `eq2`, and then transform `eq2` into `eq3`.",
		"output": "from manim import *\n\nclass MatchingEquationParts(Scene):\n    def construct(self):\n        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n        self.add(eq1)\n        self.wait(0.5)\n        self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait(0.5)"
	},
	{
		"text_input": "Create a Manim scene where an axes object ax is plotted with a sine function using ax.plot(np.sin, color=RED). Use ValueTracker to animate alpha from 0 to 1. Define point using always_redraw to continuously update a dot positioned on the sine curve at alpha. Define tangent using always_redraw to continuously update a tangent line to the sine curve at alpha, colored yellow and with a length of 4. Add ax, sine, point, and tangent to the scene and animate alpha from 0 to 1 with a linear rate function over 2 seconds.",
		"output": "from manim import *\nimport numpy as np\n\nclass TangentAnimation(Scene):\n def construct(self):\n ax = Axes()\n sine = ax.plot(np.sin, color=RED)\n alpha = ValueTracker(0)\n point = always_redraw(\n lambda: Dot(\n sine.point_from_proportion(alpha.get_value()),\n color=BLUE\n )\n )\n tangent = always_redraw(\n lambda: TangentLine(\n sine,\n alpha=alpha.get_value(),\n color=YELLOW,\n length=4\n )\n )\n self.add(ax, sine, point, tangent)\n self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)"
	},
	{
		"text_input": "Create a Manim scene where a triangle `tri` and a square `sq` are added to the scene. Use `always_rotate` to continuously rotate `tri` around the origin at a rate of `2*PI` radians per second. Animate `sq` to move from the left edge to the right edge using `sq.animate.to_edge(RIGHT)` over 1 second with a linear rate function.",
		"output": "from manim import *\n\nclass SpinningTriangle(Scene):\n    def construct(self):\n        tri = Triangle().set_fill(opacity=1).set_z_index(2)\n        sq = Square().to_edge(LEFT)\n\n        always_rotate(tri, rate=2*PI, about_point=ORIGIN)\n\n        self.add(tri, sq)\n        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)"
	},
	{
		"text_input": "Create a Manim scene where a square `sq` and a triangle `tri` are arranged horizontally on the left side of the screen. Use `always_shift` to continuously shift `sq` to the right at a rate of `5` Manim units per second. Add `sq` initially to the scene and animate `tri` to set its fill opacity to `1`.",
		"output": "from manim import *\n\nclass ShiftingSquare(Scene):\n    def construct(self):\n        sq = Square().set_fill(opacity=1)\n        tri = Triangle()\n        VGroup(sq, tri).arrange(LEFT)\n\n        always_shift(sq, RIGHT, rate=5)\n\n        self.add(sq)\n        self.play(tri.animate.set_fill(opacity=1))"
	},
	{
		"text_input": "Create a Manim scene named `WelcomeToManim` where a text `words` saying 'Welcome to' and a scaled `ManimBanner` `banner` are arranged vertically. Use `turn_animation_into_updater` to turn a `Write` animation on `words` with a run time of `0.9` seconds into an updater. Initially, add `words` to the scene, wait for `0.5` seconds, and then play an animation to expand `banner` with a run time of `0.5` seconds.",
		"output": "from manim import *\n\nclass WelcomeToManim(Scene):\n    def construct(self):\n        words = Text(\"Welcome to\")\n        banner = ManimBanner().scale(0.5)\n        VGroup(words, banner).arrange(DOWN)\n\n        turn_animation_into_updater(Write(words, run_time=0.9))\n        self.add(words)\n        self.wait(0.5)\n        self.play(banner.expand(), run_time=0.5)"
	},
	{
		"text_input": "Explain the purpose of the Scene class in Manim and provide an example where the construct method is overridden to display 'Hello World!' using the Write animation.",
		"output": "from manim import *\n\nclass MyScene(Scene):\n def construct(self):\n self.play(Write(Text('Hello World!')))"
	},
	{
		"text_input": "provide a scene that plays a sound at different points while changing the color of a green dot in the middle of the screen.",
		"output": "from manim import *\n\nclass SoundExample(Scene):\n    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        self.add_sound(\"click.wav\")\n        self.add(dot)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(BLUE)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(RED)\n        self.wait()"
	},
	{
		"text_input": "Demonstrate how to add subcaptions to animations in Manim, including both using the add_subcaption method and specifying subcaptions within the play method.",
		"output": "class SubcaptionExample(Scene):\n    def construct(self):\n        square = Square()\n        circle = Circle()\n\n        # first option: via the add_subcaption method\n        self.add_subcaption(\"Hello square!\", duration=1)\n        self.play(Create(square))\n\n        # second option: within the call to Scene.play\n        self.play(\n            Transform(square, circle),\n            subcaption=\"The square transforms.\"\n        )"
	},
	{
		"text_input": "Show an example of a typical Manim script that includes a class derived from Scene with an overridden construct method to display 'Hello World!'",
		"output": "class MyScene(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello World!\")))"
	},
	{
		"text_input": "Show an example of using LinearTransformationScene in Manim to apply a linear transformation with matrix [[1, 1], [0, 1]] and display coordinates with ghost vectors",
		"output": "from manim import *\n\nclass LinearTransformationSceneExample(LinearTransformationScene):\n def init(self, **kwargs):\n LinearTransformationScene.init(\n self,\n show_coordinates=True,\n leave_ghost_vectors=True,\n **kwargs\n )\n\n def construct(self):\n matrix = [[1, 1], [0, 1]]\n self.apply_matrix(matrix)\n self.wait()"
	},
	{
		"text_input": "Create a Bezier curve in Manim with control points at (-3, -1), (-1, 2), (1, -2), and (3, 1). Show the control points and the lines connecting them, then animate a dot moving along the curve.",
		"output": "from manim import *\n\nclass BezierCurve(Scene):\n    def construct(self):\n        # Define the control points\n        points = [\n            np.array([-3, -1, 0]),\n            np.array([-1, 2, 0]),\n            np.array([1, -2, 0]),\n            np.array([3, 1, 0])\n        ]\n\n        # Create the dots for control points\n        dots = VGroup(*[Dot(point=point) for point in points])\n        self.play(Create(dots))\n\n        # Create the control polygon (lines connecting control points)\n        control_lines = VGroup()\n        for i in range(len(points) - 1):\n            line = Line(points[i], points[i + 1])\n            control_lines.add(line)\n        self.play(Create(control_lines))\n\n        # Create the Bezier curve\n        bezier_curve = CubicBezier(points[0], points[1], points[2], points[3])\n        self.play(Create(bezier_curve))\n\n        # Animate drawing the Bezier curve\n        self.play(MoveAlongPath(Dot(), bezier_curve), run_time=5)\n\n        # Wait for a moment before ending the scene\n        self.wait()\n\nif __name__ == \"__main__\":\n    from manim import config\n    config.media_width = \"100%\"\n    config.verbosity = \"WARNING\"\n    config.background_color = \"#1E1E1E\"\n    from manim import *\n    scene = BezierCurve()\n    scene.render()"
	},
	{
		"text_input": "Create a quadratic Bézier curve in Manim with control points at (-2, 1), (0, 2), and (2, 0). Show the control points and the lines connecting them, then animate a dot moving along the curve.",
		"output": "from manim import *\n\nclass QuadraticBezierCurve(Scene):\n    def construct(self):\n        # Define the control points\n        points = [\n            np.array([-2, 1, 0]),\n            np.array([0, 2, 0]),\n            np.array([2, 0, 0])\n        ]\n\n        # Create dots for control points\n        dots = VGroup(*[Dot(point=point) for point in points])\n        self.play(Create(dots))\n\n        # Create lines connecting control points\n        control_lines = VGroup()\n        for i in range(len(points) - 1):\n            line = Line(points[i], points[i + 1])\n            control_lines.add(line)\n        self.play(Create(control_lines))\n\n        # Create the quadratic Bézier curve\n        bezier_curve = QuadraticBezier(points[0], points[1], points[2])\n        self.play(Create(bezier_curve))\n\n        # Animate drawing the Bézier curve\n        self.play(MoveAlongPath(Dot(), bezier_curve), run_time=4)\n\n        # Wait for a moment before ending the scene\n        self.wait()\n\nif __name__ == '__main__':\n    from manim import config\n    config.media_width = \"100%\"\n    config.verbosity = \"WARNING\"\n    config.background_color = \"#1E1E1E\"\n    from manim import *\n    scene = QuadraticBezierCurve()\n    scene.render()"
	},
	{
		"text_input": "Create a 3D cubic Bézier curve in Manim with control points at (-3, -1, 0), (-1, 2, 1), (1, -2, -1), and (3, 1, 0). Show the 3D control points and the lines connecting them, then animate a dot moving along the curve.",
		"output": "from manim import *\n\nclass CubicBezier3D(Scene):\n    def construct(self):\n        # Define the control points in 3D\n        points = [\n            np.array([-3, -1, 0]),\n            np.array([-1, 2, 1]),\n            np.array([1, -2, -1]),\n            np.array([3, 1, 0])\n        ]\n\n        # Create dots for control points\n        dots = VGroup(*[Dot3D(point=point) for point in points])\n        self.play(Create(dots))\n\n        # Create lines connecting control points\n        control_lines = VGroup()\n        for i in range(len(points) - 1):\n            line = Line3D(points[i], points[i + 1])\n            control_lines.add(line)\n        self.play(Create(control_lines))\n\n        # Create the cubic Bézier curve in 3D\n        bezier_curve = ParametricFunction(lambda t: bezier([points[0], points[1], points[2], points[3]])(t), t_range=[0, 1])\n        self.play(Create(bezier_curve))\n\n        # Animate drawing the Bézier curve in 3D\n        self.play(MoveAlongPath(Dot3D(), bezier_curve), run_time=5)\n\n        # Wait for a moment before ending the scene\n        self.wait()\n\nif __name__ == '__main__':\n    from manim import config\n    config.media_width = \"100%\"\n    config.verbosity = \"WARNING\"\n    config.background_color = \"#1E1E1E\"\n    from manim import *\n    scene = CubicBezier3D()\n    scene.render()"
	},
	{
		"text_input": "Create a Manim scene demonstrating color operations. Display a text with RGB color (0.2, 0.8, 0.4) shifted upwards, another text with RGBA color (0.5, 0.1, 0.9, 0.7) shifted downwards, a text showing the hexadecimal representation of the RGB color, and a text displaying the interpolated color between the RGB and RGBA colors.",
		"output": "from manim import *\n\nclass ColorExample(Scene):\n    def construct(self):\n        # Create a ManimColor from RGB tuple\n        rgb_color = ManimColor.from_rgb((0.2, 0.8, 0.4))\n        self.add(Text(\"RGB Color\", color=rgb_color).shift(UP))\n\n        # Create a ManimColor from RGBA tuple\n        rgba_color = ManimColor.from_rgba((0.5, 0.1, 0.9, 0.7))\n        self.add(Text(\"RGBA Color\", color=rgba_color).shift(DOWN))\n\n        # Convert to hexadecimal representation\n        hex_color = rgb_color.to_hex()\n        self.add(Text(f\"Hex Color: {hex_color}\", color=WHITE).shift(2 * LEFT))\n\n        # Interpolate between two colors\n        interpolated_color = rgb_color.interpolate(rgba_color, 0.5)\n        self.add(Text(\"Interpolated Color\", color=interpolated_color).shift(2 * RIGHT))\n\n        # Display the scene\n        self.wait()\n\nif __name__ == \"__main__\":\n    config.media_width = \"100%\"\n    config.background_color = \"#1E1E1E\"\n    config.verbosity = \"WARNING\"\n    scene = ColorExample()\n    scene.render()"
	},
	{
		"text_input": "Create a Manim scene demonstrating different cap styles for arcs. Display arcs with cap styles from CapStyleType arranged horizontally with a buffer of 1.5 units between them. Include labels below each arc indicating its cap style name.",
		"output": "from manim import *\n\nclass CapStyleVariants(Scene):\n    def construct(self):\n        arcs = VGroup(*[\n            Arc(\n                radius=1,\n                start_angle=0,\n                angle=TAU / 4,\n                stroke_width=20,\n                color=GREEN,\n                cap_style=cap_style,\n            )\n            for cap_style in CapStyleType\n        ])\n        arcs.arrange(RIGHT, buff=1.5)\n        self.add(arcs)\n        \n        labels = VGroup()\n        for arc in arcs:\n            label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)\n            labels.add(label)\n        \n        self.add(labels)\n\nif __name__ == \"__main__\":\n    config.media_width = \"100%\"\n    config.background_color = \"#1E1E1E\"\n    config.verbosity = \"WARNING\"\n    scene = CapStyleVariants()\n    scene.render()"
	},
	{
		"text_input": "Create a Manim scene demonstrating different line joint types using LineJointType. Display VMobjects with stroke_width=20 and color=GREEN, each set with points_as_corners. Duplicate these VMobjects for each LineJointType and assign the joint_type attribute accordingly. Arrange these VMobjects horizontally with a buffer of 1 unit between them. Display labels below each VMobject indicating its joint type name.",
		"output": "from manim import *\n\nclass LineJointVariants(Scene):\n    def construct(self):\n        mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([\n            np.array([-2, 0, 0]),\n            np.array([0, 0, 0]),\n            np.array([-2, 1, 0]),\n        ])\n        lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])\n        for line, joint_type in zip(lines, LineJointType):\n            line.joint_type = joint_type\n\n        lines.arrange(RIGHT, buff=1)\n        self.add(lines)\n        for line in lines:\n            label = Text(line.joint_type.name).next_to(line, DOWN)\n            self.add(label)\n\nif __name__ == \"__main__\":\n    config.media_width = \"100%\"\n    config.background_color = \"#1E1E1E\"\n    config.verbosity = \"WARNING\"\n    scene = LineJointVariants()\n    scene.render()"
	},
	{
		"text_input": "Demonstrate the usage of index_labels from Manim's debugging utilities to label the submobjects of a VGroup consisting of a Circle and Square. Set the label height to 0.2, background stroke width to 3, and background stroke color to '#FFD700' (gold). Display both the original VGroup and the labeled indices in the scene.",
		"output": "from manim import *; class IndexLabelsExample(Scene): def construct(self): text = MathTex('\\frac{d}{dx}f(x)g(x)=', 'f(x)\\frac{d}{dx}g(x)', '+', 'g(x)\\frac{d}{dx}f(x)',); indices = index_labels(text[0]); text[0][1].set_color(PURPLE_B); text[0][8:12].set_color(DARK_BLUE); self.add(text, indices)"
	},
	{
		"text_input": "create a scene with a math equation showing the product rule for differentiation and index labels on the first term, highlighting specific parts in different colors",
		"output": "from manim import *\n\nclass IndexLabelsExample(Scene):\n    def construct(self):\n        text = MathTex(\n            '\\frac{d}{dx}f(x)g(x)=',\n            'f(x)\\frac{d}{dx}g(x)',\n            '+',\n            'g(x)\\frac{d}{dx}f(x)',\n        )\n\n        #index the fist term in the MathTex mob\n        indices = index_labels(text[0])\n\n        text[0][1].set_color(PURPLE_B)\n        text[0][8:12].set_color(DARK_BLUE)\n\n        self.add(text, indices)"
	},
	{
		"text_input": "create a Manim scene with a MathTex object representing the product rule for differentiation. Index the first term in the MathTex object and highlight the 'd' in the first term with purple and the fraction 'dx' with dark blue.",
		"output": "from manim import *\n\nclass IndexLabelsExample(Scene):\n    def construct(self):\n        text = MathTex(\n            '\\frac{d}{dx}f(x)g(x)=',\n            'f(x)\\frac{d}{dx}g(x)',\n            '+',\n            'g(x)\\frac{d}{dx}f(x)',\n        )\n\n        #index the fist term in the MathTex mob\n        indices = index_labels(text[0])\n\n        text[0][1].set_color(PURPLE_B)\n        text[0][8:12].set_color(DARK_BLUE)\n\n        self.add(text, indices)"
	},
	{
		"text_input": "create a Manim scene demonstrating an arithmetic sequence. Include a title, description, sequence example, common difference, arrows showing the common difference between terms, and the formula for the n-th term.",
		"output": "from manim import *\n\nclass ArithmeticSequence(Scene):\n    def construct(self):\n        title = Text('Arithmetic Sequence').to_edge(UP)\n        self.play(Write(title))\n\n        description = Tex(\n            r'An arithmetic sequence is a sequence of numbers in which the difference '\n            r'between consecutive terms is constant.'\n        ).scale(0.6).next_to(title, DOWN, buff=0.5)\n\n        self.play(FadeIn(description))\n        \n        sequence_label = Tex(r'Sequence:').to_edge(LEFT).shift(UP * 2)\n        self.play(Write(sequence_label))\n        \n        # Arithmetic sequence example: a, a+d, a+2d, a+3d, ...\n        a, d = 2, 3\n        terms = [a + i * d for i in range(5)]\n        \n        sequence = VGroup(*[\n            Tex(str(term)).scale(0.8)\n            for term in terms\n        ])\n        \n        for i, term in enumerate(sequence):\n            term.next_to(sequence_label, RIGHT, buff=0.8 + i * 0.8)\n        \n        self.play(*[Write(term) for term in sequence])\n        \n        diff_label = Tex(r'Common Difference (d):').to_edge(LEFT).shift(DOWN * 1)\n        self.play(Write(diff_label))\n        \n        common_difference = Tex(f'{d}').next_to(diff_label, RIGHT, buff=0.5)\n        self.play(Write(common_difference))\n        \n        # Adding arrows to show the common difference\n        arrows = VGroup(*[\n            Arrow(start=sequence[i].get_right(), end=sequence[i+1].get_left(), buff=0.1)\n            for i in range(len(sequence) - 1)\n        ])\n        \n        diff_texts = VGroup(*[\n            Tex(f'+{d}').scale(0.6).next_to(arrows[i], UP, buff=0.1)\n            for i in range(len(arrows))\n        ])\n        \n        self.play(*[Write(arrow) for arrow in arrows])\n        self.play(*[Write(diff_text) for diff_text in diff_texts])\n        \n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Tex(\n            r'The $n$-th term of an arithmetic sequence can be found using the formula:', \n            r'$a_n = a + (n-1)d$'\n        ).scale(0.6).next_to(diff_label, DOWN, buff=1)\n        \n        self.play(FadeIn(conclusion[0]))\n        self.play(FadeIn(conclusion[1]))\n        \n        self.wait(3)"
	},
	{
		"text_input": "create a Manim scene demonstrating how to solve quadratic equations using the quadratic formula. Include the quadratic equation, the quadratic formula, an example equation, the values of a, b, and c, substitution into the formula, simplification of the discriminant, the final solutions, and a conclusion.",
		"output": "from manim import *\n\nclass QuadraticFormula(Scene):\n    def construct(self):\n        # Title\n        title = Text('Solving Quadratic Equations').to_edge(UP)\n        self.play(Write(title))\n\n        # Quadratic equation form\n        equation = MathTex('ax^2 + bx + c = 0').scale(1.2)\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Quadratic formula\n        formula = MathTex(r'x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}').scale(1.2).next_to(equation, DOWN, buff=1)\n        self.play(Write(formula))\n        self.wait(2)\n\n        # Example quadratic equation\n        example = MathTex('2x^2 + 3x - 2 = 0').scale(1.2).next_to(formula, DOWN, buff=1)\n        self.play(Write(example))\n        self.wait(1)\n\n        # Values for a, b, and c\n        values = VGroup(\n            MathTex('a = 2').to_edge(LEFT).shift(DOWN*2),\n            MathTex('b = 3').next_to(example, DOWN, aligned_edge=LEFT),\n            MathTex('c = -2').to_edge(RIGHT).shift(DOWN*2),\n        )\n        self.play(*[Write(value) for value in values])\n        self.wait(2)\n\n        # Substitute into the quadratic formula\n        substitution = MathTex(r'x = \\frac{-3 \\pm \\sqrt{3^2 - 4 \\cdot 2 \\cdot (-2)}}{2 \\cdot 2}').scale(1.2)\n        substitution.next_to(example, DOWN, buff=1)\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Simplify the discriminant\n        discriminant = MathTex(r'3^2 - 4 \\cdot 2 \\cdot (-2) = 9 + 16 = 25').next_to(substitution, DOWN, buff=1)\n        self.play(Write(discriminant))\n        self.wait(2)\n\n        # Final solutions\n        solutions = VGroup(\n            MathTex(r'x = \\frac{-3 + \\sqrt{25}}{4} = \\frac{-3 + 5}{4} = \\frac{2}{4} = \\frac{1}{2}').scale(1),\n            MathTex(r'x = \\frac{-3 - \\sqrt{25}}{4} = \\frac{-3 - 5}{4} = \\frac{-8}{4} = -2').scale(1),\n        ).arrange(DOWN, aligned_edge=LEFT).next_to(discriminant, DOWN, buff=1)\n        \n        self.play(Write(solutions[0]))\n        self.wait(2)\n        self.play(Write(solutions[1]))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text('The solutions to the equation are x = 1/2 and x = -2.').next_to(solutions, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)"
	},
	{
		"text_input": "create a Manim scene demonstrating the transformation of dots using the clockwise_path function from utils.paths. Start with dots positioned to the left (UP, DOWN, LEFT) in different colors, and transform them to positions on the right (ORIGIN, UP, DOWN) in the same colors, following a clockwise path around a half circle.",
		"output": "from manim import *\n\nclass ClockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[Dot(LEFT + pos, color=color) for pos, color in zip([UP, DOWN, LEFT], colors)]\n        )\n\n        finish_points = VGroup(\n            *[Dot(RIGHT + pos, color=color) for pos, color in zip([ORIGIN, UP, DOWN], colors)]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.clockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait()"
	},
	{
		"text_input": "create a Manim scene demonstrating the transformation of dots using the counterclockwise_path function from utils.paths. Start with dots positioned to the left (UP, DOWN, LEFT) in different colors, and transform them to positions on the right (ORIGIN, UP, DOWN) in the same colors, following a counterclockwise path around a half circle.",
		"output": "from manim import *\n\nclass CounterclockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[Dot(LEFT + pos, color=color) for pos, color in zip([UP, DOWN, LEFT], colors)]\n        )\n\n        finish_points = VGroup(\n            *[Dot(RIGHT + pos, color=color) for pos, color in zip([ORIGIN, UP, DOWN], colors)]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.counterclockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait()"
	},
	{
		"text_input": "create a Manim scene demonstrating the transformation of dots using the path_along_arc function from utils.paths. Start with dots positioned to the left (UP, DOWN, LEFT) in different colors, and transform them to positions on the right (ORIGIN, UP, DOWN) in the same colors, moving each dot along a circular arc with an angle of TAU * 2 / 3 radians (which is 240 degrees).",
		"output": "from manim import *\n\nclass PathAlongArcExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[Dot(LEFT + pos, color=color) for pos, color in zip([UP, DOWN, LEFT], colors)]\n        )\n\n        finish_points = VGroup(\n            *[Dot(RIGHT + pos, color=color) for pos, color in zip([ORIGIN, UP, DOWN], colors)]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_arc(TAU * 2 / 3),\n                run_time=3,\n            )\n        )\n        self.wait()"
	},
	{
		"text_input": "create a Manim scene demonstrating the transformation of dots using the path_along_circles function from utils.paths. Start with dots positioned to the left (UP, DOWN, LEFT) in different colors, and transform them to positions on the right (ORIGIN, UP, DOWN) in the same colors, moving each dot along a quasicircle path with an angle of 2 * PI radians (a full circle) around a center located at 3 units to the left.",
		"output": "from manim import *\n\nclass PathAlongCirclesExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[Dot(LEFT + pos, color=color) for pos, color in zip([UP, DOWN, LEFT], colors)]\n        )\n\n        finish_points = VGroup(\n            *[Dot(RIGHT + pos, color=color) for pos, color in zip([ORIGIN, UP, DOWN], colors)]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        circle_center = Dot(3 * LEFT)\n        self.add(circle_center)\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_circles(\n                    2 * PI, circle_center.get_center()\n                ),\n                run_time=3,\n            )\n        )\n        self.wait()"
	},
	{
		"text_input": "create a Manim scene demonstrating the transformation of dots using the spiral_path function from utils.paths. Start with dots positioned to the left (UP, DOWN, LEFT) in different colors, and transform them to positions on the right (ORIGIN, UP, DOWN) in the same colors, moving each dot along a spiral path with an angle of 2 * TAU radians (which completes two full circles).",
		"output": "from manim import *\n\nclass SpiralPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[Dot(LEFT + pos, color=color) for pos, color in zip([UP, DOWN, LEFT], colors)]\n        )\n\n        finish_points = VGroup(\n            *[Dot(RIGHT + pos, color=color) for pos, color in zip([ORIGIN, UP, DOWN], colors)]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.spiral_path(2 * TAU),\n                run_time=5,\n            )\n        )\n        self.wait()"
	},
	{
		"text_input": "create a Manim scene demonstrating the transformation of dots using the straight_path function from utils.paths. Start with dots positioned to the left (UP, DOWN, LEFT) in different colors, and transform them to positions on the right (ORIGIN, UP, DOWN) in the same colors, moving each dot in a straight line path towards its destination.",
		"output": "from manim import *\n\nclass StraightPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[Dot(LEFT + pos, color=color) for pos, color in zip([UP, DOWN, LEFT], colors)]\n        )\n\n        finish_points = VGroup(\n            *[Dot(RIGHT + pos, color=color) for pos, color in zip([ORIGIN, UP, DOWN], colors)]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.straight_path(),\n                run_time=2,\n            )\n        )\n        self.wait()"
	},
	{
		"text_input": "create a Manim scene demonstrating the visualization of adjacent pairs of elements in a list. Start with dots positioned horizontally to represent elements [1, 2, 3, 4, 5] in blue. Connect each pair of adjacent dots with white lines and label each dot with its corresponding element. Then, cyclically highlight each adjacent pair in red.",
		"output": "from manim import *\n\nclass AdjacentPairsVisualization(Scene):\n    def construct(self):\n        # Define the list of elements\n        elements = [1, 2, 3, 4, 5]\n\n        # Create dots to represent elements\n        dots = VGroup(*[\n            Dot(point=RIGHT * i, color=BLUE)\n            for i in range(len(elements))\n        ])\n\n        # Display the dots\n        self.add(dots)\n\n        # Create lines to connect adjacent pairs\n        lines = VGroup()\n        for i in range(len(elements)):\n            line = Line(dots[i].get_center(), dots[(i + 1) % len(elements)].get_center(), color=WHITE)\n            lines.add(line)\n\n        # Display the lines\n        self.play(Create(lines))\n\n        # Create labels for the elements\n        labels = VGroup(*[\n            MathTex(str(elements[i])).next_to(dots[i], UP)\n            for i in range(len(elements))\n        ])\n\n        # Display the labels\n        self.play(Write(labels))\n\n        # Highlight adjacent pairs cyclically\n        pairs = VGroup()\n        for i in range(len(elements)):\n            pair = Line(dots[i].get_center(), dots[(i + 1) % len(elements)].get_center(), color=RED)\n            pairs.add(pair)\n\n        # Display the highlighted pairs\n        self.play(Transform(lines, pairs))\n\n        # Conclusion\n        self.wait(2)"
	},
	{
		"text_input": "create a Manim scene demonstrating easing functions. Display three colored lines (red, green, blue) horizontally with corresponding dots at their starting points. Label each line with 'Ease In', 'Ease Out', and 'Ease In Out' respectively. Fade in the lines, dots, and labels. Then animate each dot along its corresponding line using different easing functions: 'Ease In' with 'there_and_back', 'Ease Out' with 'there_and_back_with_pause', and 'Ease In Out' with 'smooth'.",
		"output": "from manim import *\n\nclass EasingFunctions(Scene):\n    def construct(self):\n        # Create lines and dots for visualization\n        line1 = Line(3 * LEFT, 3 * RIGHT).shift(UP).set_color(RED)\n        line2 = Line(3 * LEFT, 3 * RIGHT).set_color(GREEN)\n        line3 = Line(3 * LEFT, 3 * RIGHT).shift(DOWN).set_color(BLUE)\n\n        dot1 = Dot().move_to(line1.get_left())\n        dot2 = Dot().move_to(line2.get_left())\n        dot3 = Dot().move_to(line3.get_left())\n\n        label1 = Tex(\"Ease In\").next_to(line1, RIGHT)\n        label2 = Tex(\"Ease Out\").next_to(line2, RIGHT)\n        label3 = Tex(\"Ease In Out\").next_to(line3, RIGHT)\n\n        # Fade in lines, dots, and labels\n        self.play(\n            FadeIn(VGroup(line1, line2, line3)),\n            FadeIn(VGroup(dot1, dot2, dot3)),\n            Write(VGroup(label1, label2, label3)),\n        )\n\n        # Animate dots along lines with different easing functions\n        self.play(\n            MoveAlongPath(dot1, line1, rate_func=there_and_back),\n            MoveAlongPath(dot2, line2, rate_func=there_and_back_with_pause),\n            MoveAlongPath(dot3, line3, rate_func=smooth),\n            run_time=5\n        )\n\n        self.wait()"
	},
	{
		"text_input": "Create a scene in Manim that demonstrates various rate functions by plotting their graphs in a grid layout, excluding functions that start with '__', 'sqrt', or 'bezier'. Each plot should include a title with the rate function's name. The functions 'not_quite_there' and 'squish_rate_func' should be skipped.",
		"output": "from manim import *\n\nclass RateFuncExample(Scene):\n    def construct(self):\n        x = VGroup()\n        for k, v in rate_functions.__dict__.items():\n            if 'function' in str(v):\n                if (\n                    not k.startswith('__')\n                    and not k.startswith('sqrt')\n                    and not k.startswith('bezier')\n                ):\n                    try:\n                        rate_func = v\n                        plot = (\n                            ParametricFunction(\n                                lambda x: [x, rate_func(x), 0],\n                                t_range=[0, 1, .01],\n                                use_smoothing=False,\n                                color=YELLOW,\n                            )\n                            .stretch_to_fit_width(1.5)\n                            .stretch_to_fit_height(1)\n                        )\n                        plot_bg = SurroundingRectangle(plot).set_color(WHITE)\n                        plot_title = (\n                            Text(rate_func.__name__, weight=BOLD)\n                            .scale(0.5)\n                            .next_to(plot_bg, UP, buff=0.1)\n                        )\n                        x.add(VGroup(plot_bg, plot, plot_title))\n                    except: # because functions `not_quite_there`, `function squish_rate_func` are not working.\n                        pass\n        x.arrange_in_grid(cols=8)\n        x.height = config.frame_height\n        x.width = config.frame_width\n        x.move_to(ORIGIN).scale(0.95)\n        self.add(x)"
	},
	{
		"text_input": "Create a Manim scene that visualizes a binary search to find the root of the quadratic function f(x) = x^2 + 3x + 1. The target value is 0, the lower bound is -4, and the upper bound is 1. The scene should plot the quadratic function, perform a binary search to find the root, and then display the solution on the graph with a dot and a label.",
		"output": "from manim import *\n\nclass BinarySearchVisualization(Scene):\n    def construct(self):\n        # Define the quadratic function\n        def quadratic_function(x):\n            return x**2 + 3*x + 1\n        \n        target_value = 0\n        lower_bound = -4\n        upper_bound = 1\n\n        # Perform binary search\n        solution = self.binary_search(quadratic_function, target_value, lower_bound, upper_bound)\n\n        # Plot the quadratic function\n        axes = Axes(\n            x_range=[-5, 2, 1],\n            y_range=[-10, 10, 2],\n            axis_config={\"color\": WHITE}\n        ).add_coordinates()\n        graph = axes.plot(quadratic_function, color=YELLOW)\n        target_line = axes.plot(lambda x: target_value, color=RED, x_range=[-5, 2])\n        solution_dot = Dot(axes.coords_to_point(solution, target_value), color=BLUE)\n        solution_label = MathTex(f\"x \\\\approx {solution:.2f}\").next_to(solution_dot, UP)\n\n        # Animate the plot\n        self.play(Create(axes), Create(graph), Create(target_line))\n        self.play(FadeIn(solution_dot), Write(solution_label))\n        self.wait(2)\n\n    def binary_search(self, function, target, lower_bound, upper_bound, tolerance=0.0001):\n        while upper_bound - lower_bound > tolerance:\n            midpoint = (lower_bound + upper_bound) / 2\n            if function(midpoint) < target:\n                lower_bound = midpoint\n            else:\n                upper_bound = midpoint\n        return (lower_bound + upper_bound) / 2\n\n# To run the scene, use:\n# manim -pql <filename>.py BinarySearchVisualization"
	},
	{
		"text_input": "Create a Manim scene where the camera zooms in on the text 'Hello World' and then restores to its original state.",
		"output": "from manim import *\n\nclass ChangingCameraWidthAndRestore(MovingCameraScene):\n    def construct(self):\n        text = Text('Hello World').set_color(BLUE)\n        self.add(text)\n        self.camera.frame.save_state()\n        self.play(self.camera.frame.animate.set(width=text.width * 1.2))\n        self.wait(0.3)\n        self.play(Restore(self.camera.frame))"
	},
	{
		"text_input": "Create a Manim scene where the camera zooms in on the text 'Hello World' and then restores to its original state.",
		"output": "from manim import *\n\nclass ChangingCameraWidthAndRestore(MovingCameraScene):\n    def construct(self):\n        text = Text('Hello World').set_color(BLUE)\n        self.add(text)\n        self.camera.frame.save_state()\n        self.play(self.camera.frame.animate.set(width=text.width * 1.2))\n        self.wait(0.3)\n        self.play(Restore(self.camera.frame))"
	},
	{
		"text_input": "Create a Manim scene where the camera moves between a red square and a green triangle positioned on opposite sides of the screen.",
		"output": "from manim import *\n\nclass MovingCameraCenter(MovingCameraScene):\n    def construct(self):\n        s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)\n        t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)\n        self.wait(0.3)\n        self.add(s, t)\n        self.play(self.camera.frame.animate.move_to(s))\n        self.wait(0.3)\n        self.play(self.camera.frame.animate.move_to(t))"
	},
	{
		"text_input": "Create a Manim scene where the camera moves and zooms in on a blue square and a yellow triangle, then returns to the origin and zooms out.",
		"output": "from manim import *\n\nclass MovingAndZoomingCamera(MovingCameraScene):\n    def construct(self):\n        s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)\n        t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)\n        self.add(s, t)\n        self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))\n        self.wait(0.3)\n        self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))\n\n        self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))"
	},
	{
		"text_input": "Create a Manim scene where the camera zooms in on a sine graph plotted on an axis and moves between two dots placed at the start and end points of the graph, then restores to its original state.",
		"output": "from manim import *\n\nclass MovingCameraOnGraph(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])\n\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n        self.add(ax, graph, dot_1, dot_2)\n\n        self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))\n        self.play(self.camera.frame.animate.move_to(dot_2))\n        self.play(Restore(self.camera.frame))\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene displaying a 3D surface defined by the equation z = sin(x) * cos(y), with initial camera rotation around the surface followed by a change in camera orientation.",
		"output": "from manim import *\n\nclass ThreeDSurface(ThreeDScene):\n    def construct(self):\n        # Create the axes\n        axes = ThreeDAxes()\n\n        # Define the surface equation\n        def surface_func(u, v):\n            x = u\n            y = v\n            z = np.sin(x) * np.cos(y)\n            return np.array([x, y, z])\n\n        # Create the surface\n        surface = Surface(\n            surface_func,\n            u_range=[-3, 3],\n            v_range=[-3, 3],\n            fill_opacity=0.75,\n            checkerboard_colors=[BLUE_D, BLUE_E]\n        )\n\n        # Add axes and surface to the scene\n        self.add(axes, surface)\n\n        # Set the initial camera orientation\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n\n        # Begin ambient camera rotation\n        self.begin_ambient_camera_rotation(rate=0.1)  # Increase rotation speed\n\n        # Shorten the wait time\n        self.wait(3)\n\n        # Stop the camera rotation\n        self.stop_ambient_camera_rotation()\n\n        # Change camera orientation to a new angle\n        self.move_camera(phi=60 * DEGREES, theta=-45 * DEGREES, run_time=2)\n\n        # Shorten the final hold time\n        self.wait(2)\n\n# Run the scene\nif __name__ == \"__main__\":\n    scene = ThreeDSurface()\n    scene.render()"
	},
	{
		"text_input": "Create a Manim scene demonstrating a linear transformation that scales a grid by a factor of 2 along both x and y axes.",
		"output": "from manim import *\n\nclass ScalingTransformation(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[2, 0], [0, 2]]\n        self.apply_matrix(matrix)\n        self.wait()"
	},
	{
		"text_input": "Create a Manim scene demonstrating a shear linear transformation that shears a grid using a transformation matrix [[1, 1], [0, 1]].",
		"output": "from manim import *\n\nclass ShearTransformation(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[1, 1], [0, 1]]\n        self.apply_matrix(matrix)\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating a linear transformation that rotates a grid by 60 degrees (angle = π/3).",
	"output": "from manim import *\n\nclass RotationTransformation(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        angle = PI / 3  # 60 degrees\n        matrix = [[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]]\n        self.apply_matrix(matrix)\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating a linear transformation that reflects a grid across the line y = x.",
	"output": "from manim import *\n\nclass ReflectionTransformation(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[0, 1], [1, 0]]  # Reflection across the line y = x\n        self.apply_matrix(matrix)\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating multiple linear transformations: scaling the grid by a factor of 2 and then applying a shear transformation.",
	"output": "from manim import *\n\nclass MultipleTransformations(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix1 = [[2, 0], [0, 2]]  # Scaling\n        matrix2 = [[1, 0], [1, 1]]  # Shear\n        self.apply_matrix(matrix1)\n        self.wait()\n        self.apply_matrix(matrix2)\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating the addition of two 2x2 matrices, showing the original matrices and their sum.",
	"output": "from manim import *\n\nclass MatrixAddition(Scene):\n    def construct(self):\n        # Create matrices\n        matrix1 = Matrix([[1, 2], [3, 4]])\n        matrix2 = Matrix([[5, 6], [7, 8]])\n        \n        # Position the matrices\n        matrix1.shift(LEFT * 3)\n        matrix2.shift(RIGHT * 3)\n        \n        # Display the matrices\n        self.play(Write(matrix1), Write(matrix2))\n        self.wait()\n        \n        # Matrix addition\n        matrix_sum = Matrix([[6, 8], [10, 12]])\n        matrix_sum.shift(DOWN * 2)\n        self.play(Transform(matrix1.copy(), matrix_sum.copy()),\n                  Transform(matrix2.copy(), matrix_sum.copy()),\n                  Write(MathTex(\"+\").next_to(matrix_sum, LEFT)))\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating the subtraction of two 2x2 matrices, showing the original matrices and their difference.",
	"output": "from manim import *\n\nclass MatrixSubtraction(Scene):\n    def construct(self):\n        # Create matrices\n        matrix1 = Matrix([[1, 2], [3, 4]])\n        matrix2 = Matrix([[5, 6], [7, 8]])\n        \n        # Position the matrices\n        matrix1.shift(LEFT * 3)\n        matrix2.shift(RIGHT * 3)\n        \n        # Display the matrices\n        self.play(Write(matrix1), Write(matrix2))\n        self.wait()\n        \n        # Matrix subtraction\n        matrix_diff = Matrix([[-4, -4], [-4, -4]])\n        matrix_diff.shift(DOWN * 2)\n        self.play(Transform(matrix1.copy(), matrix_diff.copy()),\n                  Transform(matrix2.copy(), matrix_diff.copy()),\n                  Write(MathTex(\"-\").next_to(matrix_diff, LEFT)))\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating the dot product of two 2-dimensional vectors, showing the original vectors and the calculation of their dot product.",
	"output": "from manim import *\n\nclass DotProduct(Scene):\n    def construct(self):\n        # Create vectors\n        vector1 = Matrix([[1], [2]])\n        vector2 = Matrix([[3], [4]])\n        \n        # Position the vectors\n        vector1.shift(LEFT * 3)\n        vector2.shift(RIGHT * 3)\n        \n        # Display the vectors\n        self.play(Write(vector1), Write(vector2))\n        self.wait()\n        \n        # Dot product\n        dot_product = MathTex(r\"\\text{Dot Product: }\", \"1 \\cdot 3 + 2 \\cdot 4 = 11\")\n        dot_product.shift(DOWN * 2)\n        self.play(Write(dot_product))\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating the subtraction of the matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]], showing the original matrices and their difference [[-4, -4], [-4, -4]].",
	"output": "from manim import *\n\nclass MatrixSubtraction(Scene):\n    def construct(self):\n        # Create matrices\n        matrix1 = Matrix([[1, 2], [3, 4]])\n        matrix2 = Matrix([[5, 6], [7, 8]])\n        \n        # Position the matrices\n        matrix1.shift(LEFT * 3)\n        matrix2.shift(RIGHT * 3)\n        \n        # Display the matrices\n        self.play(Write(matrix1), Write(matrix2))\n        self.wait()\n        \n        # Matrix subtraction\n        matrix_diff = Matrix([[-4, -4], [-4, -4]])\n        matrix_diff.shift(DOWN * 2)\n        self.play(Transform(matrix1.copy(), matrix_diff.copy()),\n                  Transform(matrix2.copy(), matrix_diff.copy()),\n                  Write(MathTex(\"-\").next_to(matrix_diff, LEFT)))\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating the dot product of the vectors [1, 2] and [3, 4], showing the original vectors and the calculation '1 * 3 + 2 * 4 = 11'.",
	"output": "from manim import *\n\nclass DotProduct(Scene):\n    def construct(self):\n        # Create vectors\n        vector1 = Matrix([[1], [2]])\n        vector2 = Matrix([[3], [4]])\n        \n        # Position the vectors\n        vector1.shift(LEFT * 3)\n        vector2.shift(RIGHT * 3)\n        \n        # Display the vectors\n        self.play(Write(vector1), Write(vector2))\n        self.wait()\n        \n        # Dot product\n        dot_product = MathTex(r\"\\text{Dot Product: }\", \"1 \\cdot 3 + 2 \\cdot 4 = 11\")\n        dot_product.shift(DOWN * 2)\n        self.play(Write(dot_product))\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating the addition of the matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]], showing the original matrices and their sum [[6, 8], [10, 12]].",
	"output": "from manim import *\n\nclass MatrixAddition(Scene):\n    def construct(self):\n        # Create matrices\n        matrix1 = Matrix([[1, 2], [3, 4]])\n        matrix2 = Matrix([[5, 6], [7, 8]])\n        \n        # Position the matrices\n        matrix1.shift(LEFT * 3)\n        matrix2.shift(RIGHT * 3)\n        \n        # Display the matrices\n        self.play(Write(matrix1), Write(matrix2))\n        self.wait()\n        \n        # Matrix addition\n        matrix_sum = Matrix([[6, 8], [10, 12]])\n        matrix_sum.shift(DOWN * 2)\n        self.play(Transform(matrix1.copy(), matrix_sum.copy()),\n                  Transform(matrix2.copy(), matrix_sum.copy()),\n                  Write(MathTex(\"+\").next_to(matrix_sum, LEFT)))\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene showing a 2x2 matrix with elements [pi, 3] and [1, 5], where the brackets are colored blue and green.",
	"output": "from manim import *\n\nclass GetBracketsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\pi\", 3], [1, 5]])\n        bra = m0.get_brackets()\n        colors = [BLUE, GREEN]\n        for k in range(len(colors)):\n            bra[k].set_color(colors[k])\n        self.add(m0)"
	},
	{
	"text_input": "Create a Manim scene showing a 2x2 matrix with elements [pi, 3] and [1, 5], where the second column is highlighted with a surrounding rectangle.",
	"output": "from manim import *\n\nclass GetColumnsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\n        self.add(m0)"
	},
	{
	"text_input": "Create a Manim scene showing a 2x2 matrix with elements [2, 3] and [1, 5], where each entry is colored differently: blue, green, yellow, and red.",
	"output": "from manim import *\n\nclass GetEntriesExample(Scene):\n    def construct(self):\n        m0 = Matrix([[2, 3], [1, 5]])\n        ent = m0.get_entries()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        self.add(m0)"
	},
	{
	"text_input": "Create a Manim scene showing a 2x2 matrix with elements [π, 3] and [1, 5], where the second row is highlighted with a surrounding rectangle.",
	"output": "from manim import *\n\nclass GetRowsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_rows()[1]))\n        self.add(m0)"
	},
	{
	"text_input": "Create a Manim scene demonstrating different matrix examples: m0 with elements [2, π], [-1, 1]; m1 with elements [2, 0, 4], [-1, 1, 5], brackets {}, and the second column highlighted; m2 with elements [2, 1], [-1, 3], aligned to the upper-left corner with brackets (); m3 with elements [2, 1], [-1, 3], using angle brackets \\langle \\rangle for brackets; m4 with elements [2, 1], [-1, 3], with the first column colored red and the second column colored green; m5 with elements [2, 1], [-1, 3], with the first row colored red and the second row colored green.",
	"output": "from manim import *\n\nclass MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[2, \"\\pi\"], [-1, 1]])\n        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\n            v_buff=1.3,\n            h_buff=0.8,\n            bracket_h_buff=SMALL_BUFF,\n            bracket_v_buff=SMALL_BUFF,\n            left_bracket=\"{\",\n            right_bracket=\"}\")\n        m1.add(SurroundingRectangle(m1.get_columns()[1]))\n        m2 = Matrix([[2, 1], [-1, 3]],\n            element_alignment_corner=UL,\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m3 = Matrix([[2, 1], [-1, 3]],\n            left_bracket=\"\\langle\",\n            right_bracket=\"\\rangle\")\n        m4 = Matrix([[2, 1], [-1, 3]],\n        ).set_column_colors(RED, GREEN)\n        m5 = Matrix([[2, 1], [-1, 3]],\n        ).set_row_colors(RED, GREEN)\n        g = Group(\n            m0,m1,m2,m3,m4,m5\n        ).arrange_in_grid(buff=2)\n        self.add(g)"
	},
	{
	"text_input": "Create a Manim scene demonstrating the use of background rectangles: a scaled rectangle with opacity 0.5 and colors teal, red, and yellow; m0 with elements [12, -30], [-1, 15] with background rectangles added to entries; m1 with elements [2, 0], [-1, 1] with a background rectangle around the entire matrix; m2 with elements [12, -30], [-1, 15] without additional background rectangles.",
	"output": "from manim import *\n\nclass BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background= Rectangle().scale(3.2)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        m0 = Matrix([[12, -30], [-1, 15]],\n            add_background_rectangles_to_entries=True)\n        m1 = Matrix([[2, 0], [-1, 1]],\n            include_background_rectangle=True)\n        m2 = Matrix([[12, -30], [-1, 15]])\n        g = Group(m0, m1, m2).arrange(buff=2)\n        self.add(g)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a simple number line from 0 to 10, with numbers displayed and highlighted in red at positions 3 and 7.",
	"output": "from manim import *\n\nclass SimpleNumberLine(Scene):\n    def construct(self):\n        # Create a simple number line from 0 to 10\n        number_line = NumberLine(\n            x_range=[0, 10, 1],\n            length=10,\n            include_numbers=True,\n            font_size=36,\n            color=BLUE,\n        )\n        \n        # Position the number line in the center of the scene\n        number_line.shift(DOWN)\n        \n        # Add a title above the number line\n        title = Text(\"Number Line\", font_size=48).next_to(number_line, UP, buff=0.5)\n        \n        # Animate the creation of the title and number line\n        self.play(Write(title))\n        self.play(Create(number_line))\n        self.wait()\n        \n        # Highlight numbers 3 and 7\n        highlighted_numbers = [number_line.numbers[3], number_line.numbers[7]]\n        self.play(*[num.animate.set_color(RED) for num in highlighted_numbers])\n        self.wait()"
	},
	{
	"text_input": "Create a Manim scene demonstrating a unit circle with a dot moving along its circumference, displaying the sine value dynamically as the dot moves, with a label 'sin(θ) =' and a horizontal line showing the vertical position of the dot.",
	"output": "from manim import *\n\nclass SineUnitCircle(Scene):\n    def construct(self):\n        # Create a unit circle\n        unit_circle = Circle(radius=1, color=BLUE)\n        \n        # Create a dot that moves along the circumference of the unit circle\n        dot = Dot(RIGHT)\n        \n        # Create a DecimalNumber to display the sine value\n        sine_label = DecimalNumber(0, color=RED, num_decimal_places=2, include_sign=True)\n        \n        # Create a label for sine\n        sine_text = Tex(\"$sin(\\theta) = $\", color=RED).next_to(sine_label, LEFT)\n        \n        # Create a line from the origin to the dot\n        line = Line(ORIGIN, dot.get_center(), color=YELLOW)\n        \n        # Create a horizontal line from the dot to the vertical axis\n        horizontal_line = always_redraw(lambda: Line(\n            dot.get_center(),\n            [0, dot.get_center()[1], 0],\n            color=RED\n        ))\n        \n        # Function to update the sine label and lines\n        def update_sine_label(mobject):\n            # Update the sine label based on the dot's position\n            sine_label.set_value(dot.get_center()[1]).next_to(sine_text, RIGHT)\n            \n            # Update the line to connect the origin and the dot\n            line.put_start_and_end_on(ORIGIN, dot.get_center())\n        \n        # Add updaters to the sine label and line\n        sine_label.add_updater(update_sine_label)\n        line.add_updater(update_sine_label)\n        \n        # Add the unit circle, dot, sine label, line, and horizontal line to the scene\n        self.add(unit_circle, dot, sine_text, sine_label, line, horizontal_line)\n        \n        # Rotate the dot around the unit circle\n        self.play(MoveAlongPath(dot, unit_circle), run_time=8, rate_func=linear)\n        \n        # Remove updaters to stop updating after animation\n        sine_label.remove_updater(update_sine_label)\n        line.remove_updater(update_sine_label)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a unit circle with a dot moving along its circumference, displaying the cosine value dynamically as the dot moves, with a label 'cos(θ) =' and a horizontal line showing the horizontal position of the dot.",
	"output": "from manim import *\n\nclass CosineUnitCircle(Scene):\n    def construct(self):\n        # Create a unit circle\n        unit_circle = Circle(radius=1, color=BLUE)\n        \n        # Create a dot that moves along the circumference of the unit circle\n        dot = Dot(RIGHT)\n        \n        # Create a DecimalNumber to display the cosine value\n        cosine_label = DecimalNumber(1, color=GREEN, num_decimal_places=2, include_sign=True)\n        \n        # Create a label for cosine\n        cosine_text = Tex(\"$cos(\\theta) = $\", color=GREEN).next_to(cosine_label, LEFT)\n        \n        # Create a line from the origin to the dot\n        line = Line(ORIGIN, dot.get_center(), color=YELLOW)\n        \n        # Create a horizontal line from the dot to the y-axis\n        h_line = always_redraw(lambda: Line(\n            dot.get_center(),\n            [dot.get_center()[0], 0, 0],\n            color=RED,\n            stroke_width=2,\n        ))\n        \n        # Function to update the cosine label and lines\n        def update_label(mobject):\n            # Update the cosine label based on the dot's position\n            cosine_label.set_value(dot.get_center()[0]).next_to(cosine_text, RIGHT)\n            \n            # Update the line to connect the origin and the dot\n            line.put_start_and_end_on(ORIGIN, dot.get_center())\n        \n        # Add an updater to the cosine label\n        cosine_label.add_updater(update_label)\n        \n        # Add the unit circle, dot, cosine label, lines, and angle to the scene\n        self.add(unit_circle, dot, cosine_text, cosine_label, line, h_line)\n        \n        # Rotate the dot around the unit circle\n        self.play(MoveAlongPath(dot, unit_circle), run_time=8, rate_func=linear)\n        \n        # Remove the updater to stop updating after animation\n        cosine_label.remove_updater(update_label)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a 3D dodecahedron.",
	"output": "from manim import *\n\nclass DodecahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Dodecahedron()\n        self.add(obj)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a 3D icosahedron with specific camera orientation.",
	"output": "from manim import *\n\nclass IcosahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Icosahedron()\n        self.add(obj)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a 3D octahedron with specific camera orientation.",
	"output": "from manim import *\n\nclass OctahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Octahedron()\n        self.add(obj)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a 3D square pyramid with specific vertex coordinates and face list.",
	"output": "from manim import *\n\nclass SquarePyramidScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        vertex_coords = [\n            [1, 1, 0],\n            [1, -1, 0],\n            [-1, -1, 0],\n            [-1, 1, 0],\n            [0, 0, 2]\n        ]\n        faces_list = [\n            [0, 1, 4],\n            [1, 2, 4],\n            [2, 3, 4],\n            [3, 0, 4],\n            [0, 1, 2, 3]\n        ]\n        pyramid = Polyhedron(vertex_coords, faces_list)\n        self.add(pyramid)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a 3D octahedron with specific edge length, highlighting one edge in red and one face in yellow.",
	"output": "from manim import *\n\nclass PolyhedronSubMobjects(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        octahedron = Octahedron(edge_length = 3)\n        octahedron.graph[0].set_color(RED)\n        octahedron.faces[2].set_color(YELLOW)\n        self.add(octahedron)"
	},
	{
	"text_input": "Create a Manim scene demonstrating a 3D tetrahedron with a specified edge length.",
	"output": "from manim import *\n\nclass TetrahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Tetrahedron()\n        self.add(obj)"
	},
	
	
	
	
	
	{
	"text_input": "Create a Manim scene demonstrating the volume and surface area calculations for a cube with a side length of 2 units, including animations to highlight each calculation and display the formulas.",
	"output": "from manim import *\n\nclass CubeVolumeAndSurfaceArea(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n\n        # Create a cube\n        cube = Cube(side_length=2, color=BLUE)\n\n        # Add labels for volume and surface area\n        volume_label = Tex(\"Volume = $a^3$\").to_corner(UL)\n        surface_area_label = Tex(\"Surface Area = $6a^2$\").to_corner(UR)\n\n        # Add the cube and labels to the scene\n        self.add(cube, volume_label, surface_area_label)\n\n        # Rotate the cube\n        self.play(Rotate(cube, angle=PI/2, about_point=ORIGIN, axis=UP), run_time=2)\n\n        # Highlight the volume\n        self.play(\n            cube.animate.set_fill(BLUE, opacity=0.5),\n            volume_label.animate.set_color(YELLOW),\n            run_time=2\n        )\n        self.wait(1)\n\n        # Highlight the surface area\n        self.play(\n            cube.animate.set_fill(BLUE, opacity=0),\n            volume_label.animate.set_color(WHITE),\n            surface_area_label.animate.set_color(YELLOW),\n            run_time=2\n        )\n\n        # Show the formula for volume\n        volume_formula = Tex(\"$V = a \\times a \\times a$\").next_to(volume_label, DOWN)\n        self.play(Write(volume_formula))\n        self.wait(1)\n\n        # Show the formula for surface area\n        surface_area_formula = Tex(\"$SA = 6 \\times a \\times a$\").next_to(surface_area_label, DOWN)\n        self.play(Write(surface_area_formula))\n        self.wait(2)"
	},















	{
        "text_input": "Create a scene in Manim that demonstrates the usage of the AnnularSector class with different configurations for inner radius, outer radius, angle, and color. The background color should be set to white for clear visualization of changes in fill opacity. Place four different annular sectors in the four quadrants of the scene.",
        "output": "from manim import *\\n\\nclass AnnularSectorExample(Scene):\\n    def construct(self):\\n        # Changes background color to clearly visualize changes in fill_opacity.\\n        self.camera.background_color = WHITE\\n\\n        # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.\\n        s1 = AnnularSector(color=YELLOW).move_to(2 * UL)\\n\\n        # Different inner_radius and outer_radius than the default.\\n        s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)\\n\\n        # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.\\n        s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)\\n\\n        # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.\\n        s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)\\n\\n        self.add(s1, s2, s3, s4)"
    },
    {
        "text_input": "Implement a Manim scene showcasing two Annulus objects with different inner and outer radii. The first annulus should have an inner radius of 0.5 and an outer radius of 1, positioned above the second annulus. The second annulus should have an inner radius of 0.3, an outer radius of 0.6, and be colored red, placed below the first annulus.",
        "output": "from manim import *\\n\\nclass AnnulusExample(Scene):\\n    def construct(self):\\n        annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)\\n        annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)\\n        self.add(annulus_1, annulus_2)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the usage of the Arc class with an angle of \u03c0 radians (180 degrees).",
        "output": "from manim import *\\n\\nclass ArcExample(Scene):\\n    def construct(self):\\n        self.add(Arc(angle=PI))"
    },
    {
        "text_input": "Create a Manim scene illustrating the construction of an arc between two points on a circle. The circle should have a radius of 2 and a grey stroke color. Place two green dots at coordinates (2,0) and (0,2) respectively, with corresponding labels next to each dot in blue. Generate a yellow arc between the points (2,0) and (0,2).",
        "output": "from manim import *\\n\\nclass ArcBetweenPointsExample(Scene):\\n    def construct(self):\\n        circle = Circle(radius=2, stroke_color=GREY)\\n        dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)\\n        dot_1_text = Tex(\"(2,0)\").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)\\n        dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)\\n        dot_2_text = Tex(\"(0,2)\").scale(0.5).next_to(dot_2, UP).set_color(BLUE)\\n        arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)\\n        self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)\\n        self.play(Create(arc))"
    },
    {
        "text_input": "Implement a Manim scene showcasing multiple ArcPolygon objects with different configurations. Create four ArcPolygon instances with the following specifications:\n\nThe first ArcPolygon should connect points at coordinates (0,0), (2,0), and (0,2) with a radius of 2.\n\nThe second ArcPolygon should connect the same points with an angle of 45 degrees.\n\nThe third ArcPolygon should use an arc configuration dictionary specifying a radius of 1.7 and a color of red.\n\nThe fourth ArcPolygon should demonstrate multiple arcs with specific configurations:\n\nThe first arc with a radius of 1.7 and red color.\nThe second arc with an angle of 20 degrees and blue color.\nThe third arc with a radius of 1.\nArrange all ArcPolygon objects in a VGroup and animate their creation in the scene.",
        "output": "from manim import *\\n\\nclass SeveralArcPolygons(Scene):\\n    def construct(self):\\n        a = [0, 0, 0]\\n        b = [2, 0, 0]\\n        c = [0, 2, 0]\\n        ap1 = ArcPolygon(a, b, c, radius=2)\\n        ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)\\n        ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})\\n        ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,\\n                                    arc_config=[{'radius': 1.7, 'color': RED},\\n                                    {'angle': 20*DEGREES, 'color': BLUE},\\n                                    {'radius': 1}])\\n        ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()\\n        self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])\\n        self.wait()"
    },
    {
        "text_input": "Create a Manim scene illustrating the construction of a Reuleaux triangle using ArcBetweenPoints and ArcPolygonFromArcs. Define three points:\n\nPoint a at coordinates (-1, 0, 0)\nPoint b at coordinates (1, 0, 0)\nPoint c at coordinates (0, \u221a3, 0)\nGenerate three arcs between these points with a radius of 2, each configured with a stroke width of 0. Use these arcs to construct a Reuleaux triangle with the following polygon configuration:\n\nSet the stroke width to 10, stroke color to blue, fill opacity to 1, and color to purple.\nFade in the Reuleaux triangle in the scene.",
        "output": "from manim import *\\n\\nclass ArcPolygonExample(Scene):\\n    def construct(self):\\n        arc_conf = {\"stroke_width\": 0}\\n        poly_conf = {\"stroke_width\": 10, \"stroke_color\": BLUE,\\n              \"fill_opacity\": 1, \"color\": PURPLE}\\n        a = [-1, 0, 0]\\n        b = [1, 0, 0]\\n        c = [0, np.sqrt(3), 0]\\n        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\\n        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\\n        arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)\\n        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\\n        self.play(FadeIn(reuleaux_tri))\\n        self.wait(2)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the construction of a modified Reuleaux triangle using ArcBetweenPoints and ArcPolygonFromArcs. Define three points:\n\nPoint a at coordinates (-1, 0, 0)\nPoint b at coordinates (1, 0, 0)\nPoint c at coordinates (0, \u221a3, 0)\nGenerate three arcs between these points with a radius of 2:\n\nThe first arc (arc0) should have a stroke width of 3, stroke color of blue, fill opacity of 0.5, and color of green.\nThe second arc (arc1) should inherit these properties from arc_conf.\nThe third arc (arc2) should have a stroke color of red.\nConstruct the Reuleaux triangle using these arcs, ensuring no specific color is set (color set to None). Fade in the Reuleaux triangle in the scene.",
        "output": "from manim import *\\n\\nclass ArcPolygonExample2(Scene):\\n    def construct(self):\\n        arc_conf = {\"stroke_width\": 3, \"stroke_color\": BLUE,\\n            \"fill_opacity\": 0.5, \"color\": GREEN}\\n        poly_conf = {\"color\": None}\\n        a = [-1, 0, 0]\\n        b = [1, 0, 0]\\n        c = [0, np.sqrt(3), 0]\\n        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\\n        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\\n        arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)\\n        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\\n        self.play(FadeIn(reuleaux_tri))\\n        self.wait(2)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the usage of the Circle class to display three circles:\n\nThe first circle (circle_1) should have a radius of 1.0.\n\nThe second circle (circle_2) should have a radius of 1.5 and be colored green.\n\nThe third circle (circle_3) should have a radius of 1.0, be colored using the BLUE_B color constant, and have a fill opacity of 1.\n\nArrange these circles in a group with a buffer of 1 unit between them and add them to the scene.",
        "output": "from manim import *\\n\\nclass CircleExample(Scene):\\n    def construct(self):\\n        circle_1 = Circle(radius=1.0)\\n        circle_2 = Circle(radius=1.5, color=GREEN)\\n        circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)\\n\\n        circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)\\n        self.add(circle_group)\\n"
    },
    {
        "text_input": "Implement a Manim scene illustrating the construction of a circle using Circle.from_three_points method. Define three points:\n\nPoint A at coordinates LEFT\nPoint B at coordinates LEFT + UP\nPoint C at coordinates UP * 2\nCreate a circle (circle) using these three points with a color set to red. Additionally, display three dots (dots) at each of the defined points on a number plane (NumberPlane).",
        "output": "from manim import *\\n\\nclass CircleFromPointsExample(Scene):\\n    def construct(self):\\n        circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)\\n        dots = VGroup(\\n            Dot(LEFT),\\n            Dot(LEFT + UP),\\n            Dot(UP * 2),\\n        )\\n        self.add(NumberPlane(), circle, dots)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the usage of the point_at_angle method from the Circle class.\n\nDefine a circle (circle) with a radius of 2.0.\n\nUse the point_at_angle method to determine two points (p1 and p2) on the circle:\n\np1 should be located at an angle of \u03c0/2 radians (90 degrees) from the positive x-axis.\np2 should be located at an angle of 270 degrees (or 270 * DEGREES) from the positive x-axis.\nCreate two square shapes (s1 and s2) with a side length of 0.25. Position s1 at point p1 and s2 at point p2.\n\nAdd the circle, squares (s1, s2), and circles to the scene.",
        "output": "from manim import *\\n\\nclass PointAtAngleExample(Scene):\\n    def construct(self):\\n        circle = Circle(radius=2.0)\\n        p1 = circle.point_at_angle(PI/2)\\n        p2 = circle.point_at_angle(270*DEGREES)\\n\\n        s1 = Square(side_length=0.25).move_to(p1)\\n        s2 = Square(side_length=0.25).move_to(p2)\\n        self.add(circle, s1, s2)"
    },
    {
        "text_input": "Implement a Manim scene showcasing the usage of the surround method with different geometric shapes:\n\nCreate a triangle (triangle1) and surround it with a circle (circle1). Treat both objects as a single group (group1).\n\nDraw a line (line2) and surround it with a circle (circle2) using a buffer factor of 2.0. Group them together (group2).\n\nGenerate a square (square3) and surround it with a circle (circle3) using a buffer factor of 0.5, making the circle smaller than the square. Group them together (group3).\n\nArrange all groups (group1, group2, group3) in a larger group with a buffer of 1 unit between them. Add this group to the scene.",
        "output": "from manim import *\\n\\nclass CircleSurround(Scene):\\n    def construct(self):\\n        triangle1 = Triangle()\\n        circle1 = Circle().surround(triangle1)\\n        group1 = Group(triangle1,circle1) # treat the two mobjects as one\\n\\n        line2 = Line()\\n        circle2 = Circle().surround(line2, buffer_factor=2.0)\\n        group2 = Group(line2,circle2)\\n\\n        # buffer_factor < 1, so the circle is smaller than the square\\n        square3 = Square()\\n        circle3 = Circle().surround(square3, buffer_factor=0.5)\\n        group3 = Group(square3, circle3)\\n\\n        group = Group(group1, group2, group3).arrange(buff=1)\\n        self.add(group)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the construction of a cubic Bezier spline (CubicBezier). Define two control points:\n\nPoint p1 located at coordinates (-3, 1, 0), represented by a blue dot (d1).\nPoint p2 located at coordinates (3, -1, 0), represented by a red dot (d2).\nDraw lines (l1, l2) from each point to their respective control points (p1b, p2b).\n\nConstruct a cubic Bezier curve (bezier) using the following control points:\n\np1b as the starting point.\np1b + 3 * RIGHT as the first control point.\np2b - 3 * RIGHT as the second control point.\np2b as the ending point.\nAdd the lines, dots, and the cubic Bezier curve to the scene.",
        "output": "from manim import *\\n\\nclass BezierSplineExample(Scene):\\n    def construct(self):\\n        p1 = np.array([-3, 1, 0])\\n        p1b = p1 + [1, 0, 0]\\n        d1 = Dot(point=p1).set_color(BLUE)\\n        l1 = Line(p1, p1b)\\n        p2 = np.array([3, -1, 0])\\n        p2b = p2 - [1, 0, 0]\\n        d2 = Dot(point=p2).set_color(RED)\\n        l2 = Line(p2, p2b)\\n        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)\\n        self.add(l1, d1, l2, d2, bezier)"
    },
    {
        "text_input": "Implement a Manim scene demonstrating the usage of the Dot class to create three dots (dot1, dot2, dot3):\n\nPlace dot1 at the coordinate LEFT with a radius of 0.08 units.\n\nPosition dot2 at the origin (ORIGIN).\n\nSet dot3 at the coordinate RIGHT.\n\nAdd all three dots to the scene.",
        "output": "from manim import *\\n\\nclass DotExample(Scene):\\n    def construct(self):\\n        dot1 = Dot(point=LEFT, radius=0.08)\\n        dot2 = Dot(point=ORIGIN)\\n        dot3 = Dot(point=RIGHT)\\n        self.add(dot1,dot2,dot3)"
    },
    {
        "text_input": "Create a Manim scene illustrating the usage of the Ellipse class to display two ellipses (ellipse_1 and ellipse_2):\n\nThe first ellipse (ellipse_1) should have a width of 2.0 units, a height of 4.0 units, and be colored using the BLUE_B color constant.\n\nThe second ellipse (ellipse_2) should have a width of 4.0 units, a height of 1.0 units, and be colored using the BLUE_D color constant.\n\nArrange both ellipses in a group (ellipse_group) with a buffer of 1 unit between them. Add this group to the scene.",
        "output": "from manim import *\\n\\nclass EllipseExample(Scene):\\n    def construct(self):\\n        ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)\\n        ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)\\n        ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)\\n        self.add(ellipse_group)"
    },
    {
        "text_input": "Implement a Manim scene demonstrating the creation of several labeled dots (dot1, dot2, dot3, dot4) positioned around a red square (sq):\n\nCreate a red square (sq) with a fill color of red (RED) and fill opacity of 1.0. Add it to the scene.\n\nDefine four labeled dots:\n\ndot1 labeled with the text \"42\" in red color (RED).\ndot2 labeled with the math expression \"a\" in green color (GREEN).\ndot3 labeled with the text \"ii\" in blue color (BLUE).\ndot4 labeled with the number \"3\".\nPosition these dots relative to the square (sq):\n\ndot1 should be placed up-left (UL) to the square.\ndot2 should be placed up-right (UR) to the square.\ndot3 should be placed down-left (DL) to the square.\ndot4 should be placed down-right (DR) to the square.\nAdd all dots (dot1, dot2, dot3, dot4) to the scene.",
        "output": "from manim import *\\n\\nclass SeveralLabeledDots(Scene):\\n    def construct(self):\\n        sq = Square(fill_color=RED, fill_opacity=1)\\n        self.add(sq)\\n        dot1 = LabeledDot(Tex(\"42\", color=RED))\\n        dot2 = LabeledDot(MathTex(\"a\", color=GREEN))\\n        dot3 = LabeledDot(Text(\"ii\", color=BLUE))\\n        dot4 = LabeledDot(\"3\")\\n        dot1.next_to(sq, UL)\\n        dot2.next_to(sq, UR)\\n        dot3.next_to(sq, DL)\\n        dot4.next_to(sq, DR)\\n        self.add(dot1, dot2, dot3, dot4)"
    },
    {
        "text_input": "Create a Manim scene illustrating the usage of the Sector class to display two sectors (sector and sector2):\n\nDefine sector with an outer radius of 2 units and an inner radius of 1 unit. Set its color to red (RED).\n\nPosition sector2 with an outer radius of 2.5 units and an inner radius of 0.8 units, moved to coordinates [-3, 0, 0]. Set its color to pink (PINK).\n\nAdd both sectors (sector and sector2) to the scene.",
        "output": "from manim import *\\n\\nclass ExampleSector(Scene):\\n    def construct(self):\\n        sector = Sector(outer_radius=2, inner_radius=1)\\n        sector2 = Sector(outer_radius=2.5, inner_radius=0.8).move_to([-3, 0, 0])\\n        sector.set_color(RED)\\n        sector2.set_color(PINK)\\n        self.add(sector, sector2)"
    },
    {
        "text_input": "Implement a Manim scene demonstrating the use of the Difference class to illustrate the difference of two shapes (sq and cr):\n\nCreate a red square (sq) with a fill opacity of 1.0, moved to coordinates [-2, 0, 0].\n\nDefine a blue circle (cr) with a fill opacity of 1.0, moved to coordinates [-1.3, 0.7, 0].\n\nConstruct a shape (un) that represents the difference between sq and cr. Set its color to green (GREEN) and place it at coordinates [1.5, 0, 0].\n\nAdd all shapes (sq, cr, un) to the scene.\n\n",
        "output": "from manim import *\\n\\nclass DifferenceExample(Scene):\\n    def construct(self):\\n        sq = Square(color=RED, fill_opacity=1)\\n        sq.move_to([-2, 0, 0])\\n        cr = Circle(color=BLUE, fill_opacity=1)\\n        cr.move_to([-1.3, 0.7, 0])\\n        un = Difference(sq, cr, color=GREEN, fill_opacity=1)\\n        un.move_to([1.5, 0, 0])\\n        self.add(sq, cr, un)"
    },
    {
        "text_input": "Here's a prompt for the provided IntersectionExample code:\n\nImplement a Manim scene demonstrating the use of the Exclusion class to illustrate the exclusion of one shape (sq) from another (cr):\n\nCreate a red square (sq) with a fill opacity of 1.0, moved to coordinates [-2, 0, 0].\n\nDefine a blue circle (cr) with a fill opacity of 1.0, moved to coordinates [-1.3, 0.7, 0].\n\nConstruct a shape (un) that represents the exclusion of sq from cr. Set its color to green (GREEN) and place it at coordinates [1.5, 0.4, 0].\n\nAdd all shapes (sq, cr, un) to the scene.",
        "output": "from manim import *\\n\\nclass IntersectionExample(Scene):\\n    def construct(self):\\n        sq = Square(color=RED, fill_opacity=1)\\n        sq.move_to([-2, 0, 0])\\n        cr = Circle(color=BLUE, fill_opacity=1)\\n        cr.move_to([-1.3, 0.7, 0])\\n        un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)\\n        un.move_to([1.5, 0.4, 0])\\n        self.add(sq, cr, un)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of the Union class to illustrate the union of two shapes (sq and cr):\n\nDefine a red square (sq) with a fill opacity of 1.0, moved to coordinates [-2, 0, 0].\n\nCreate a blue circle (cr) with a fill opacity of 1.0, moved to coordinates [-1.3, 0.7, 0].\n\nConstruct a shape (un) representing the union of sq and cr. Set its color to green (GREEN) and place it at coordinates [1.5, 0.3, 0].\n\nAdd all shapes (sq, cr, un) to the scene.\n\n",
        "output": "from manim import *\\n\\nclass UnionExample(Scene):\\n    def construct(self):\\n        sq = Square(color=RED, fill_opacity=1)\\n        sq.move_to([-2, 0, 0])\\n        cr = Circle(color=BLUE, fill_opacity=1)\\n        cr.move_to([-1.3, 0.7, 0])\\n        un = Union(sq, cr, color=GREEN, fill_opacity=1)\\n        un.move_to([1.5, 0.3, 0])\\n        self.add(sq, cr, un)"
    },
    {
        "text_input": "Implement a Manim scene demonstrating the creation of a labeled arrow (l_arrow) with specific attributes:\n\nCreate a labeled arrow (l_arrow) with the text \"0.5\", starting at LEFT*3 and ending at RIGHT*3 + UP*2. The label should be positioned at 50% along the arrow (label_position=0.5).\nAdd the labeled arrow (l_arrow) to the scene.",
        "output": "from manim import *\\n\\nclass LabeledArrowExample(Scene):\\n    def construct(self):\\n        l_arrow = LabeledArrow(\"0.5\", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)\\n        self.add(l_arrow)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the creation of a labeled line (line) with specific attributes:\n\nDefine a labeled line (line) with the label \"0.5\", positioned at 80% along the line (label_position=0.8). Set the font size to 20 (font_size=20), the label color to white (label_color=WHITE), and enable a frame around the label (label_frame=True).\n\nPosition the line with its start point at LEFT+DOWN and its end point at RIGHT+UP.\n\nAdjust the length of the line to be twice its current length using set_length(line.get_length() * 2).\n\nAdd the labeled line (line) to the scene.",
        "output": "from manim import *\\n\\nclass LabeledLineExample(Scene):\\n    def construct(self):\\n        line = LabeledLine(\\n            label          = '0.5',\\n            label_position = 0.8,\\n            font_size      = 20,\\n            label_color    = WHITE,\\n            label_frame    = True,\\n\\n            start=LEFT+DOWN,\\n            end=RIGHT+UP)\\n\\n        line.set_length(line.get_length() * 2)\\n        self.add(line)"
    },
    {
        "text_input": "\nImplement a Manim scene demonstrating the creation of right arc angles (rightarcangles) between two lines (line1 and line2):\n\nDefine two lines (line1 from LEFT to RIGHT and line2 from DOWN to UP).\n\nCreate several right arc angles (rightarcangles) using the Angle class with the following configurations:\n\nFirst angle with default settings (Angle(line1, line2, dot=True)).\nSecond angle with a radius of 0.4, in the second quadrant ((1, -1)), and showing the other angle (other_angle=True).\nThird angle with a radius of 0.5, in the fourth quadrant ((-1, 1)), a stroke width of 8, a yellow dot of radius 0.04, and showing the other angle (other_angle=True).\nFourth angle with a radius of 0.7, in the third quadrant ((-1, -1)), colored red with a green dot of radius 0.08.\nCreate a VGroup (plots) to arrange each angle alongside copies of line1 and line2.\n\nArrange all plots (plots) with a buffer of 1.5 units between them.\n\nAdd plots to the scene.",
        "output": "from manim import *\\n\\nclass RightArcAngleExample(Scene):\\n    def construct(self):\\n        line1 = Line( LEFT, RIGHT )\\n        line2 = Line( DOWN, UP )\\n        rightarcangles = [\\n            Angle(line1, line2, dot=True),\\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),\\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),\\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),\\n        ]\\n        plots = VGroup()\\n        for angle in rightarcangles:\\n            plot=VGroup(line1.copy(),line2.copy(), angle)\\n            plots.add(plot)\\n        plots.arrange(buff=1.5)\\n        self.add(plots)"
    },
    {
        "text_input": "Create a Manim scene illustrating the use of the Angle class to display angles between two lines (line1 and line2):\n\nDefine line1 extending from LEFT + (1/3) * UP to RIGHT + (1/3) * DOWN.\n\nDefine line2 extending from DOWN + (1/3) * RIGHT to UP + (1/3) * LEFT.\n\nCreate multiple angles (angles) using the Angle class with various configurations:\n\nFirst angle without additional parameters (Angle(line1, line2)).\nSecond angle with a radius of 0.4, in the second quadrant ((1, -1)), and showing the other angle (other_angle=True).\nThird angle with a radius of 0.5, in the fourth quadrant ((-1, 1)), a stroke width of 8, and showing the other angle (other_angle=True).\nFourth angle with a radius of 0.7, in the third quadrant ((-1, -1)), colored red (RED).\nAdditional angles illustrating different combinations of radius, quadrant, stroke width, color, and display of the other angle (other_angle=True).\nCreate a VGroup (plots) to arrange each angle alongside copies of line1 and line2, enclosed within a surrounding rectangle (SurroundingRectangle(plot, buff=0.3)).\n\nArrange all plots (plots) in a 2x4 grid with a buffer of 1 unit between them (arrange_in_grid(rows=2, buff=1)).\n\nAdd plots to the scene.\n\n",
        "output": "from manim import *\\n\\nclass AngleExample(Scene):\\n    def construct(self):\\n        line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )\\n        line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )\\n        angles = [\\n            Angle(line1, line2),\\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),\\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),\\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),\\n            Angle(line1, line2, other_angle=True),\\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1)),\\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),\\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),\\n        ]\\n        plots = VGroup()\\n        for angle in angles:\\n            plot=VGroup(line1.copy(),line2.copy(), angle)\\n            plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))\\n        plots.arrange_in_grid(rows=2,buff=1)\\n        self.add(plots)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the creation of a filled angle (mfill) between two lines (l1 and l2):\n\nDefine l1 as a green line extending from the origin to 2 * UP + RIGHT.\n\nDefine l2 as a green line with the same endpoints as l1, rotated clockwise by 20 degrees about the origin.\n\nCalculate the length of l1 (norm).\n\nConstruct two angles (a1 and a2) between l1 and l2, both showing the other angle and with radii of norm - 0.5 and norm, respectively. Set their color to green.\n\nSave the coordinates of the points of a1 in q1, and the coordinates of the points of a2 in q2 (in reversed direction).\n\nConcatenate the points of q1, q2, and the starting point of q1 to ensure that the path starts and ends at the same point (pnts).\n\nCreate a VMobject (mfill) and set its points as corners using the concatenated points. Fill it with an orange color with full opacity.\n\nAdd l1, l2, and mfill to the scene.",
        "output": "from manim import *\\n\\nclass FilledAngle(Scene):\\n    def construct(self):\\n        l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)\\n        l2 = (\\n            Line(ORIGIN, 2 * UP + RIGHT)\\n            .set_color(GREEN)\\n            .rotate(-20 * DEGREES, about_point=ORIGIN)\\n        )\\n        norm = l1.get_length()\\n        a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)\\n        a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)\\n        q1 = a1.points #  save all coordinates of points of angle a1\\n        q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)\\n        pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point\\n        mfill = VMobject().set_color(ORANGE)\\n        mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)\\n        self.add(l1, l2)\\n        self.add(mfill)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of Angle.from_three_points to construct angles (sample_angle and red_angle) from three specified points:\n\nDefine sample_angle as an angle created from points UP, ORIGIN, and LEFT.\n\nDefine red_angle as an angle created from points LEFT + UP, ORIGIN, and RIGHT, with a radius of 0.8, in the third quadrant ((-1, -1)), colored RED, with a stroke width of 8, and showing the other angle (other_angle=True).\n\nAdd red_angle and sample_angle to the scene.",
        "output": "from manim import *\\n\\nclass AngleFromThreePointsExample(Scene):\\n    def construct(self):\\n        sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)\\n        red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)\\n        self.add(red_angle, sample_angle)"
    },
    {
        "text_input": "Create a Manim scene demonstrating how to retrieve and display the angle value (value) between two lines (line1 and line2):\n\nDefine line1 as a line extending from LEFT + (1/3) * UP to RIGHT + (1/3) * DOWN.\n\nDefine line2 as a line extending from DOWN + (1/3) * RIGHT to UP + (1/3) * LEFT.\n\nCalculate the angle (angle) between line1 and line2 with a radius of 0.4.\n\nCreate a DecimalNumber (value) displaying the angle value in degrees (angle.get_value(degrees=True)) and unit \"^{\\circ}\". Position it next to angle at the upper right (UR).\n\nAdd line1, line2, angle, and value to the scene.",
        "output": "from manim import *\\n\\nclass GetValueExample(Scene):\\n    def construct(self):\\n        line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)\\n        line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)\\n\\n        angle = Angle(line1, line2, radius=0.4)\\n\\n        value = DecimalNumber(angle.get_value(degrees=True), unit=\"^{\\circ}\")\\n        value.next_to(angle, UR)\\n\\n        self.add(line1, line2, angle, value)"
    },
    {
        "text_input": "Create a Manim scene demonstrating different configurations of arrows (arrow_1 to arrow_6) using various parameters:\n\nDefine arrow_1 as an arrow starting from RIGHT and ending at LEFT, colored GOLD.\n\nDefine arrow_2 similarly to arrow_1 but with a square-shaped tip (ArrowSquareTip), shifted downward (DOWN) and colored GOLD.\n\nGroup arrow_1 and arrow_2 into g1.\n\nCreate a Square (square) colored MAROON_A.\n\nDefine arrow_3 as an arrow starting from LEFT and ending at RIGHT.\n\nDefine arrow_4 similarly to arrow_3 but with no buffer (buff=0), positioned next to arrow_1 at UP.\n\nGroup arrow_3, arrow_4, and square into g2.\n\nDefine arrow_5 as an arrow starting from ORIGIN and ending at config.top, shifted left by 4 units.\n\nDefine arrow_6 as an arrow starting from config.top + DOWN and ending at config.top, shifted left by 3 units.\n\nGroup arrow_5 and arrow_6 into g3.\n\nAdd g1, g2, and g3 to the scene, arranging them horizontally with a buffer of 2.",
        "output": "from manim import *\\n\\nfrom manim.mobject.geometry.tips import ArrowSquareTip\\nclass ArrowExample(Scene):\\n    def construct(self):\\n        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)\\n        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)\\n        g1 = Group(arrow_1, arrow_2)\\n\\n        # the effect of buff\\n        square = Square(color=MAROON_A)\\n        arrow_3 = Arrow(start=LEFT, end=RIGHT)\\n        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)\\n        g2 = Group(arrow_3, arrow_4, square)\\n\\n        # a shorter arrow has a shorter tip and smaller stroke width\\n        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)\\n        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)\\n        g3 = Group(arrow_5, arrow_6)\\n\\n        self.add(Group(g1, g2, g3).arrange(buff=2))"
    },
    {
        "text_input": "Create a Manim scene showcasing various configurations of arrows (left_group, middle_group, UR_group, DR_group) using different parameters:\n\nDefine left_group as a vertical group (VGroup) of arrows extending from 2 * LEFT to 2 * RIGHT, with buff values ranging from 0 to 2.2 in steps of 0.45. Arrange them vertically and position the group at 4 * LEFT.\n\nDefine middle_group as a vertical group of arrows with varying max_stroke_width_to_length_ratio values from 0 to 5 in steps of 0.5. Arrange them vertically.\n\nDefine UR_group as a vertical group of arrows with varying max_tip_length_to_length_ratio values from 0 to 0.3 in steps of 0.1. Move this group to 4 * RIGHT + 2 * UP.\n\nDefine DR_group as a vertical group (VGroup) of arrows:\n\nFirst arrow starts from LEFT to RIGHT, colored BLUE, with ArrowSquareTip as the tip shape.\nSecond arrow starts from LEFT to RIGHT, colored BLUE, with ArrowSquareFilledTip as the tip shape.\nThird arrow starts from LEFT to RIGHT, colored YELLOW, with ArrowCircleTip as the tip shape.\nFourth arrow starts from LEFT to RIGHT, colored YELLOW, with ArrowCircleFilledTip as the tip shape.\nArrange them vertically and move the group to 4 * RIGHT + 2 * DOWN.\nAdd left_group, middle_group, UR_group, and DR_group to the scene.",
        "output": "from manim import *\\n\\nclass ArrowExample(Scene):\\n    def construct(self):\\n        left_group = VGroup()\\n        # As buff increases, the size of the arrow decreases.\\n        for buff in np.arange(0, 2.2, 0.45):\\n            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)\\n        # Required to arrange arrows.\\n        left_group.arrange(DOWN)\\n        left_group.move_to(4 * LEFT)\\n\\n        middle_group = VGroup()\\n        # As max_stroke_width_to_length_ratio gets bigger,\\n        # the width of stroke increases.\\n        for i in np.arange(0, 5, 0.5):\\n            middle_group += Arrow(max_stroke_width_to_length_ratio=i)\\n        middle_group.arrange(DOWN)\\n\\n        UR_group = VGroup()\\n        # As max_tip_length_to_length_ratio increases,\\n        # the length of the tip increases.\\n        for i in np.arange(0, 0.3, 0.1):\\n            UR_group += Arrow(max_tip_length_to_length_ratio=i)\\n        UR_group.arrange(DOWN)\\n        UR_group.move_to(4 * RIGHT + 2 * UP)\\n\\n        DR_group = VGroup()\\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)\\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)\\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)\\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)\\n        DR_group.arrange(DOWN)\\n        DR_group.move_to(4 * RIGHT + 2 * DOWN)\\n\\n        self.add(left_group, middle_group, UR_group, DR_group)"
    },
    {
        "text_input": "Create a Manim scene demonstrating different configurations of dashed lines (dashed_1, dashed_2, dashed_3) using the DashedLine class:\n\nDefine dashed_1 as a dashed line extending from config.left_side to config.right_side, with dash_length set to 2.0. Shift this line UP*2.\n\nDefine dashed_2 as a normal dashed line extending from config.left_side to config.right_side.\n\nDefine dashed_3 as a dashed line extending from config.left_side to config.right_side, with dashed_ratio set to 0.1. Shift this line DOWN*2.\n\nAdd dashed_1, dashed_2, and dashed_3 to the scene.",
        "output": "from manim import *\\n\\nclass DashedLineExample(Scene):\\n    def construct(self):\\n        # dash_length increased\\n        dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)\\n        # normal\\n        dashed_2 = DashedLine(config.left_side, config.right_side)\\n        # dashed_ratio decreased\\n        dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)\\n        self.add(dashed_1, dashed_2, dashed_3)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of DoubleArrow to show arrows on a circle (d_arrow) and with custom arrow tips (d_arrow_2):\n\nCreate a circle object with a radius of 2.0.\n\nDefine d_arrow as a DoubleArrow with its start at the left side of circle (circle.get_left()) and its end at the right side of circle (circle.get_right()).\n\nDefine d_arrow_2 as a DoubleArrow with tip_shape_start and tip_shape_end set to ArrowCircleFilledTip.\n\nArrange the elements in the scene: first group circle and d_arrow, then add d_arrow_2 below.\n\nAdd the grouped elements (group) to the scene.",
        "output": "from manim import *\\n\\nfrom manim.mobject.geometry.tips import ArrowCircleFilledTip\\nclass DoubleArrowExample(Scene):\\n    def construct(self):\\n        circle = Circle(radius=2.0)\\n        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())\\n        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)\\n        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)\\n        self.add(group)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of DoubleArrow with different parameters (d1, d2, d3) on a square (box):\n\nCreate a box object as a Square.\n\nDefine p1 as the left side of box (box.get_left()) and p2 as the right side of box (box.get_right()).\n\nDefine d1 as a DoubleArrow from p1 to p2 with buff=0.\n\nDefine d2 as a DoubleArrow from p1 to p2 with buff=0, tip_length=0.2, and color=YELLOW.\n\nDefine d3 as a DoubleArrow from p1 to p2 with buff=0, tip_length=0.4, and color=BLUE.\n\nArrange d1, d2, and d3 vertically using Group(d1, d2, d3).arrange(DOWN).\n\nAdd box, d1, d2, and d3 to the scene.",
        "output": "from manim import *\\n\\nclass DoubleArrowExample2(Scene):\\n    def construct(self):\\n        box = Square()\\n        p1 = box.get_left()\\n        p2 = box.get_right()\\n        d1 = DoubleArrow(p1, p2, buff=0)\\n        d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)\\n        d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)\\n        Group(d1, d2, d3).arrange(DOWN)\\n        self.add(box, d1, d2, d3)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of Elbow with different parameters (elbow_1, elbow_2, elbow_3):\n\nCreate elbow_1 as an instance of Elbow with default parameters.\n\nCreate elbow_2 as an instance of Elbow with width=2.0.\n\nCreate elbow_3 as an instance of Elbow with width=2.0 and angle=5*PI/4.\n\nArrange elbow_1, elbow_2, and elbow_3 horizontally using Group(elbow_1, elbow_2, elbow_3).arrange(buff=1).\n\nAdd the group containing all elbows (elbow_group) to the scene.",
        "output": "from manim import *\\n\\nclass ElbowExample(Scene):\\n    def construct(self):\\n        elbow_1 = Elbow()\\n        elbow_2 = Elbow(width=2.0)\\n        elbow_3 = Elbow(width=2.0, angle=5*PI/4)\\n\\n        elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)\\n        self.add(elbow_group)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of Line and Dot:\n\nCreate a VGroup named d and add 10 Dot objects to it. Arrange them in a grid using d.arrange_in_grid(buff=1) and add d to the scene.\n\nCreate a Line object l using the first two dots in d. Add l to the scene and wait.\n\nAnimate l to change its start and end points to connect dots 1 and 2, then dots 4 and 7 sequentially. Use l.put_start_and_end_on() and add self.wait() between each animation step.",
        "output": "from manim import *\\n\\nclass LineExample(Scene):\\n    def construct(self):\\n        d = VGroup()\\n        for i in range(0,10):\\n            d.add(Dot())\\n        d.arrange_in_grid(buff=1)\\n        self.add(d)\\n        l= Line(d[0], d[1])\\n        self.add(l)\\n        self.wait()\\n        l.put_start_and_end_on(d[1].get_center(), d[2].get_center())\\n        self.wait()\\n        l.put_start_and_end_on(d[4].get_center(), d[7].get_center())\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create right angle examples using a Scene with four different configurations. Each configuration should include two lines, with specified lengths, quadrant positions, stroke widths, and colors for the right angles.\n",
        "output": "from manim import *\\n\\nclass RightAngleExample(Scene):\\n    def construct(self):\\n        line1 = Line( LEFT, RIGHT )\\n        line2 = Line( DOWN, UP )\\n        rightangles = [\\n            RightAngle(line1, line2),\\n            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),\\n            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),\\n            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),\\n        ]\\n        plots = VGroup()\\n        for rightangle in rightangles:\\n            plot=VGroup(line1.copy(),line2.copy(), rightangle)\\n            plots.add(plot)\\n        plots.arrange(buff=1.5)\\n        self.add(plots)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating tangent lines to a circle. Create a circle with a radius of 2 units. Add two tangent lines to the circle: one tangent at the right side (alpha=0.0) colored in BLUE_D with a length of 4 units, and another tangent at the top-left side (alpha=0.4) colored in GREEN with a length of 4 units.\n",
        "output": "from manim import *\\n\\nclass TangentLineExample(Scene):\\n    def construct(self):\\n        circle = Circle(radius=2)\\n        line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right\\n        line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left\\n        self.add(circle, line_1, line_2)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating vectors on a number plane. Include the creation of a number plane and two vectors: one vector pointing to [1, 2] and another pointing to [-5, -2].\n",
        "output": "from manim import *\\n\\nclass VectorExample(Scene):\\n    def construct(self):\\n        plane = NumberPlane()\\n        vector_1 = Vector([1,2])\\n        vector_2 = Vector([-5,-2])\\n        self.add(plane, vector_1, vector_2)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of Cutout to overlay multiple shapes. Create a square scaled by 2.5, a triangle scaled by 0.5 shifted downwards and rightwards, a square scaled by 0.5 shifted upwards and rightwards, a pentagon scaled by 0.5 shifted downwards and leftwards, and a hexagon scaled by 0.5 shifted upwards and leftwards. Combine these shapes using Cutout with a fill opacity of 1, filled in BLUE, and with a RED stroke color. Animate the creation of the Cutout over 4 seconds.\n",
        "output": "from manim import *\\n\\nclass CutoutExample(Scene):\\n    def construct(self):\\n        s1 = Square().scale(2.5)\\n        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)\\n        s3 = Square().shift(UP + RIGHT).scale(0.5)\\n        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)\\n        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)\\n        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)\\n        self.play(Write(c), run_time=4)\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the creation of polygons. Create an isosceles triangle with vertices at [-5, 1.5, 0], [-2, 1.5, 0], and [-3.5, -2, 0]. Create another polygon using vertices at [4, 1, 0], [4, -2.5, 0], [0, -2.5, 0], [0, 3, 0], [2, 1, 0], and [4, 3, 0], colored in PURPLE_B.\n",
        "output": "from manim import *\\n\\nclass PolygonExample(Scene):\\n    def construct(self):\\n        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])\\n        position_list = [\\n            [4, 1, 0],  # middle right\\n            [4, -2.5, 0],  # bottom right\\n            [0, -2.5, 0],  # bottom left\\n            [0, 3, 0],  # top left\\n            [2, 1, 0],  # middle\\n            [4, 3, 0],  # top right\\n        ]\\n        square_and_triangles = Polygon(*position_list, color=PURPLE_B)\\n        self.add(isosceles, square_and_triangles)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of Polygram to create a hexagram. Define the hexagram using two sets of vertices: [[0, 2, 0], [-sqrt(3), -1, 0], [sqrt(3), -1, 0]] and [[-sqrt(3), 1, 0], [0, -2, 0], [sqrt(3), 1, 0]]. Add the hexagram to the scene, then animate a dot moving along the path of the hexagram over 5 seconds using a linear rate function.\n",
        "output": "from manim import *\\n\\nimport numpy as np\\n\\nclass PolygramExample(Scene):\\n    def construct(self):\\n        hexagram = Polygram(\\n            [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],\\n            [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],\\n        )\\n        self.add(hexagram)\\n\\n        dot = Dot()\\n        self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)\\n        self.remove(dot)\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of Rectangle to draw multiple rectangles with different parameters. Create three rectangles: one with a width of 4.0 units, height of 2.0 units, grid x-step of 1.0, and grid y-step of 0.5; another with a width of 1.0 unit and height of 4.0 units; and a third with a width of 2.0 units, height of 2.0 units, and grid x-step and y-step both set to 1.0 with grid lines of width 1. Arrange these rectangles with a buffer of 1 unit between them and add them to the scene.\n",
        "output": "from manim import *\\n\\nclass RectangleExample(Scene):\\n    def construct(self):\\n        rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)\\n        rect2 = Rectangle(width=1.0, height=4.0)\\n        rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)\\n        rect3.grid_lines.set_stroke(width=1)\\n\\n        rects = Group(rect1, rect2, rect3).arrange(buff=1)\\n        self.add(rects)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of RegularPolygon to draw multiple regular polygons with different parameters. Create three regular polygons: one with 6 sides, one with 6 sides rotated by 30 degrees, colored in GREEN, and one with 10 sides colored in RED. Scale all polygons by a factor of 1.5 and arrange them with a buffer of 1 unit between them before adding them to the scene.\n",
        "output": "from manim import *\\n\\nclass RegularPolygonExample(Scene):\\n    def construct(self):\\n        poly_1 = RegularPolygon(n=6)\\n        poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)\\n        poly_3 = RegularPolygon(n=10, color=RED)\\n\\n        poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)\\n        self.add(poly_group)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of RegularPolygram to draw a pentagram. Create a pentagram with 5 vertices and a radius of 2 units. Add the pentagram to the scene.\n",
        "output": "from manim import *\\n\\nclass RegularPolygramExample(Scene):\\n    def construct(self):\\n        pentagram = RegularPolygram(5, radius=2)\\n        self.add(pentagram)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of RoundedRectangle to draw rectangles with rounded corners. Create two rounded rectangles: one with a corner radius of 0.5 units, and another with a corner radius of 1.5 units, a height of 4.0 units, and a width of 4.0 units. Arrange the rectangles with a buffer of 1 unit between them and add them to the scene.\n",
        "output": "from manim import *\\n\\nclass RoundedRectangleExample(Scene):\\n    def construct(self):\\n        rect_1 = RoundedRectangle(corner_radius=0.5)\\n        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)\\n\\n        rect_group = Group(rect_1, rect_2).arrange(buff=1)\\n        self.add(rect_group)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of Square to draw multiple squares with different side lengths. Create three squares: one with a side length of 2.0 units shifted downwards, another with a side length of 1.0 unit positioned above the first square, and a third with a side length of 0.5 units positioned above the second square. Add all three squares to the scene.\n",
        "output": "from manim import *\\n\\nclass SquareExample(Scene):\\n    def construct(self):\\n        square_1 = Square(side_length=2.0).shift(DOWN)\\n        square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)\\n        square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)\\n        self.add(square_1, square_2, square_3)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of RegularPolygram and Star to draw shapes. Create a pentagram with 5 vertices and a radius of 2 units. Create a star with an outer radius of 2 units and color it RED. Add the pentagram to the scene, animate the creation of the star over 3 seconds, and then fade out the star over 2 seconds.\n",
        "output": "from manim import *\\n\\nclass StarExample(Scene):\\n    def construct(self):\\n        pentagram = RegularPolygram(5, radius=2)\\n        star = Star(outer_radius=2, color=RED)\\n\\n        self.add(pentagram)\\n        self.play(Create(star), run_time=3)\\n        self.play(FadeOut(star), run_time=2)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Star class with different densities. Create two stars with 7 points and an outer radius of 2 units: one with a density of 2 and colored RED, and another with a density of 3 and colored PURPLE. Arrange the stars horizontally and add them to the scene.\n",
        "output": "from manim import *\\n\\nclass DifferentDensitiesExample(Scene):\\n    def construct(self):\\n        density_2 = Star(7, outer_radius=2, density=2, color=RED)\\n        density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)\\n\\n        self.add(VGroup(density_2, density_3).arrange(RIGHT))"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of DiGraph to draw a directed graph and animate its vertices. Create a directed graph with vertices [1, 2, 3, 4] and edges [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]. Add the graph to the scene and animate the vertices to the following positions: vertex 1 to [1, 1, 1], vertex 2 to [-1, 1, 2], vertex 3 to [1, -1, -1], and vertex 4 to [-1, -1, 0]. Include a wait time at the end.\n",
        "output": "from manim import *\\n\\nclass MovingDiGraph(Scene):\\n    def construct(self):\\n        vertices = [1, 2, 3, 4]\\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\\n\\n        g = DiGraph(vertices, edges)\\n\\n        self.add(g)\\n        self.play(\\n            g[1].animate.move_to([1, 1, 1]),\\n            g[2].animate.move_to([-1, 1, 2]),\\n            g[3].animate.move_to([1, -1, -1]),\\n            g[4].animate.move_to([-1, -1, 0]),\\n        )\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of DiGraph to draw a custom directed graph with specific edge configurations. Create a directed graph with vertices [0, 1, 2, 3, 4] and edges [(0, 1), (1, 2), (3, 2), (3, 4)]. Configure the edges with a stroke width of 2 and arrow tips shaped like squares with a length of 0.15. Additionally, color the edge (3, 4) in RED and set its tip length and width to 0.25. Add labels to the vertices and use a circular layout. Scale the graph by 1.4. Animate the creation of the graph and include a wait time at the end.\n",
        "output": "from manim import *\\n\\nclass CustomDiGraph(Scene):\\n    def construct(self):\\n        vertices = [i for i in range(5)]\\n        edges = [\\n            (0, 1),\\n            (1, 2),\\n            (3, 2),\\n            (3, 4),\\n        ]\\n\\n        edge_config = {\\n            \"stroke_width\": 2,\\n            \"tip_config\": {\\n                \"tip_shape\": ArrowSquareTip,\\n                \"tip_length\": 0.15,\\n            },\\n            (3, 4): {\\n                \"color\": RED,\\n                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\\n            },\\n        }\\n\\n        g = DiGraph(\\n            vertices,\\n            edges,\\n            labels=True,\\n            layout=\"circular\",\\n            edge_config=edge_config,\\n        ).scale(1.4)\\n\\n        self.play(Create(g))\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of DiGraph to draw an undirected graph and animate its vertices. Create a graph with vertices [0, 1, 2, 3, 4] and edges [(0, 1), (1, 2), (3, 2), (3, 4)]. Configure the edges with a stroke width of 2 and no arrow tips. Color the edge (3, 4) in RED. Add labels to the vertices and use a circular layout. Scale the graph by 1.4. Animate the creation of the graph and move the vertices to the following positions: vertex 1 to [1, 1, 1], vertex 2 to [-1, 1, 2], vertex 3 to [-1.5, -1.5, -1], and vertex 4 to [1, -2, -1]. Include a wait time at the end.\n",
        "output": "from manim import *\\n\\nclass UndirectedMovingDiGraph(Scene):\\n    def construct(self):\\n        vertices = [i for i in range(5)]\\n        edges = [\\n            (0, 1),\\n            (1, 2),\\n            (3, 2),\\n            (3, 4),\\n        ]\\n\\n        edge_config = {\\n            \"stroke_width\": 2,\\n            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\\n            (3, 4): {\"color\": RED},\\n        }\\n\\n        g = DiGraph(\\n            vertices,\\n            edges,\\n            labels=True,\\n            layout=\"circular\",\\n            edge_config=edge_config,\\n        ).scale(1.4)\\n\\n        self.play(Create(g))\\n        self.wait()\\n\\n        self.play(\\n            g[1].animate.move_to([1, 1, 1]),\\n            g[2].animate.move_to([-1, 1, 2]),\\n            g[3].animate.move_to([-1.5, -1.5, -1]),\\n            g[4].animate.move_to([1, -2, -1]),\\n        )\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph and animate a layout change. Create a graph with vertices [1, 2, 3, 4, 5] and edges [(1, 2), (2, 3), (3, 4), (4, 5)]. Initialize the graph with a specific layout: vertex 1 at [-2, 0, 0], vertex 2 at [-1, 0, 0], vertex 3 at [0, 0, 0], vertex 4 at [1, 0, 0], and vertex 5 at [2, 0, 0]. Animate the creation of the graph and then change the layout to \"circular\". Include a wait time at the end.\n",
        "output": "from manim import *\\n\\nclass ChangeGraphLayout(Scene):\\n    def construct(self):\\n        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\\n                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\\n                          4: [1, 0, 0], 5: [2, 0, 0]}\\n                  )\\n        self.play(Create(G))\\n        self.play(G.animate.change_layout(\"circular\"))\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to import and animate a graph from NetworkX. Import an Erd\u0151s-R\u00e9nyi random graph with 14 vertices and edge probability 0.5 from NetworkX. Create a Manim graph from the NetworkX graph using a spring layout with a scale factor of 3.5. Animate the creation of the graph, then animate each vertex to move along a circular path centered at (5*RIGHT, 3*UP) with radius increasing linearly from 0 to 3 units. Finally, animate the removal of the graph from the scene.\n",
        "output": "from manim import *\\n\\nimport networkx as nx\\n\\nnxgraph = nx.erdos_renyi_graph(14, 0.5)\\n\\nclass ImportNetworkxGraph(Scene):\\n    def construct(self):\\n        G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)\\n        self.play(Create(G))\\n        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +\\n                                         3*UP*np.sin(ind/7 * PI))\\n                    for ind, v in enumerate(G.vertices)])\\n        self.play(Uncreate(G))"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph and animate its vertices. Create a graph with vertices [1, 2, 3, 4] and edges [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]. Animate the creation of the graph. Then, animate the vertices to move to specific positions: vertex 1 to [1, 1, 0], vertex 2 to [-1, 1, 0], vertex 3 to [1, -1, 0], and vertex 4 to [-1, -1, 0]. Include wait times at appropriate points.\n",
        "output": "from manim import *\\n\\nclass MovingVertices(Scene):\\n    def construct(self):\\n        vertices = [1, 2, 3, 4]\\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\\n        g = Graph(vertices, edges)\\n        self.play(Create(g))\\n        self.wait()\\n        self.play(g[1].animate.move_to([1, 1, 0]),\\n                  g[2].animate.move_to([-1, 1, 0]),\\n                  g[3].animate.move_to([1, -1, 0]),\\n                  g[4].animate.move_to([-1, -1, 0]))\\n        self.wait()"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw multiple graphs with different automatic layouts. Define a list of vertices [1, 2, 3, 4, 5, 6, 7, 8] and edges [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5), (2, 8), (3, 4), (6, 1), (6, 2), (6, 3), (7, 2), (7, 4)]. Create graphs using the following automatic layouts scaled by 0.5: \"spring\", \"circular\", \"kamada_kawai\", \"planar\", \"random\", \"shell\", \"spectral\", and \"spiral\". Arrange the graphs into three rows with the first row containing the first three graphs, the second row containing the next three graphs, and the third row containing the last two graphs. Arrange these rows vertically in the scene.\n",
        "output": "from manim import *\\n\\nclass GraphAutoPosition(Scene):\\n    def construct(self):\\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\\n                 (2, 8), (3, 4), (6, 1), (6, 2),\\n                 (6, 3), (7, 2), (7, 4)]\\n        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\\n                       \"planar\", \"random\", \"shell\",\\n                       \"spectral\", \"spiral\"]\\n        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\\n                  for lt in autolayouts]\\n        r1 = VGroup(*graphs[:3]).arrange()\\n        r2 = VGroup(*graphs[3:6]).arrange()\\n        r3 = VGroup(*graphs[6:]).arrange()\\n        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with manual vertex positions. Define vertices [1, 2, 3, 4] and edges [(1, 2), (2, 3), (3, 4), (4, 1)]. Set a manual layout for the vertices: vertex 1 at [0, 0, 0], vertex 2 at [1, 1, 0], vertex 3 at [1, -1, 0], and vertex 4 at [-1, 0, 0]. Create the graph using these vertices, edges, and layout, and add it to the scene.\n",
        "output": "from manim import *\\n\\nclass GraphManualPosition(Scene):\\n    def construct(self):\\n        vertices = [1, 2, 3, 4]\\n        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\\n        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\\n        G = Graph(vertices, edges, layout=lt)\\n        self.add(G)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a labeled and modified graph. Define vertices [1, 2, 3, 4, 5, 6, 7, 8] and edges [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5), (2, 8), (3, 4), (6, 1), (6, 2), (6, 3), (7, 2), (7, 4)]. Create a graph with a circular layout scaled by a factor of 3, showing vertex labels and modifying the following configurations: vertex 7 filled with RED, and edges (1, 7), (2, 7), and (4, 7) colored in RED. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass LabeledModifiedGraph(Scene):\\n    def construct(self):\\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\\n                 (2, 8), (3, 4), (6, 1), (6, 2),\\n                 (6, 3), (7, 2), (7, 4)]\\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\\n                  edge_config={(1, 7): {\"stroke_color\": RED},\\n                               (2, 7): {\"stroke_color\": RED},\\n                               (4, 7): {\"stroke_color\": RED}})\\n        self.add(g)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a partite graph imported from NetworkX. Define a NetworkX graph with nodes [0, 1, 2, 3] and edges [(0, 2), (0, 3), (1, 2)]. Create a Manim graph from the NetworkX graph using a partite layout with vertices in partitions: vertices [0, 1] in one partition. Animate the creation of the graph and add it to the scene.\n",
        "output": "from manim import *\\n\\nimport networkx as nx\\n\\nclass PartiteGraph(Scene):\\n    def construct(self):\\n        G = nx.Graph()\\n        G.add_nodes_from([0, 1, 2, 3])\\n        G.add_edges_from([(0, 2), (0,3), (1, 2)])\\n        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\\n        self.play(Create(graph))"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a neural network graph. Define a neural network with layers [2, 3, 3, 2], representing the number of neurons in each layer. Construct the edges to connect neurons between layers accordingly. Create a Graph object using these vertices and edges, with a partite layout where each layer of neurons forms a partition. Scale the layout by a factor of 3 and configure vertex radius to 0.20. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass LinearNN(Scene):\\n    def construct(self):\\n        edges = []\\n        partitions = []\\n        c = 0\\n        layers = [2, 3, 3, 2]  # the number of neurons in each layer\\n\\n        for i in layers:\\n            partitions.append(list(range(c + 1, c + i + 1)))\\n            c += i\\n        for i, v in enumerate(layers[1:]):\\n                last = sum(layers[:i+1])\\n                for j in range(v):\\n                    for k in range(last - layers[i], last):\\n                        edges.append((k + 1, j + last + 1))\\n\\n        vertices = np.arange(1, sum(layers) + 1)\\n\\n        graph = Graph(\\n            vertices,\\n            edges,\\n            layout='partite',\\n            partitions=partitions,\\n            layout_scale=3,\\n            vertex_config={'radius': 0.20},\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a tree imported from NetworkX. Define a tree structure with a root node \"ROOT\" connected to five levels of child nodes (\"Child_0\" to \"Child_4\"), each connected to their respective \"Grandchild\" and \"Greatgrandchild\" nodes. Create a Manim graph from the NetworkX tree using a tree layout with \"ROOT\" as the root vertex. Animate the creation of the graph and add it to the scene.\n",
        "output": "from manim import *\\n\\nimport networkx as nx\\n\\nclass Tree(Scene):\\n    def construct(self):\\n        G = nx.Graph()\\n\\n        G.add_node(\"ROOT\")\\n\\n        for i in range(5):\\n            G.add_node(\"Child_%i\" % i)\\n            G.add_node(\"Grandchild_%i\" % i)\\n            G.add_node(\"Greatgrandchild_%i\" % i)\\n\\n            G.add_edge(\"ROOT\", \"Child_%i\" % i)\\n            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\\n            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\\n\\n        self.play(Create(\\n            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class with a custom layout function. Define a custom layout function `custom_layout` that takes a NetworkX graph, a scale factor or tuple, and an optional parameter `n`. The function arranges nodes in a grid-like pattern based on the specified `n`. Create a graph with 7 vertices and 8 edges arranged using the custom layout function, with labels displayed on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass CustomLayoutExample(Scene):\\n    def construct(self):\\n        import numpy as np\\n        import networkx as nx\\n\\n        # create custom layout\\n        def custom_layout(\\n            graph: nx.Graph,\\n            scale: float | tuple[float, float, float] = 2,\\n            n: int | None = None,\\n            *args: Any,\\n            **kwargs: Any,\\n        ):\\n            nodes = sorted(list(graph))\\n            height = len(nodes) // n\\n            return {\\n                node: (scale * np.array([\\n                    (i % n) - (n-1)/2,\\n                    -(i // n) + height/2,\\n                    0\\n                ])) for i, node in enumerate(graph)\\n            }\\n\\n        # draw graph\\n        n = 4\\n        graph = Graph(\\n            [i for i in range(4 * 2 - 1)],\\n            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\\n            labels=True,\\n            layout=custom_layout,\\n            layout_config={'n': n}\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a circular layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)]. Use a circular layout and display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass CircularLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"circular\",\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a Kamada-Kawai layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]. Use the Kamada-Kawai layout with a layout configuration specifying distances between certain pairs of vertices. Scale the layout by a factor of 4 and display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass CircularLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"circular\",\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a partite layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)]. Use a partite layout with partitions defined as [[1, 2], [3, 4], [5, 6]]. Display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass PartiteLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"partite\",\\n            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a planar layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)]. Use a planar layout scaled by a factor of 4 and display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass PlanarLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"planar\",\\n            layout_scale=4,\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a random layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)]. Use a random layout and display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass RandomLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"random\",\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a shell layout. Define a graph with vertices [1, 2, 3, 4, 5, 6, 7, 8, 9] and edges [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)]. Use a shell layout with nlist specified as [[1, 2, 3], [4, 5, 6, 7, 8, 9]]. Display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass ShellLayout(Scene):\\n    def construct(self):\\n        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\\n            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\\n            layout=\"shell\",\\n            layout_config={\"nlist\": nlist},\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a spectral layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)]. Use a spectral layout and display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass SpectralLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"spectral\",\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a spiral layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)]. Use a spiral layout and display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass SpiralLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"spiral\",\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Generate the Manim code to create a scene demonstrating the use of the Graph class to draw a graph with a spring layout. Define a graph with vertices [1, 2, 3, 4, 5, 6] and edges [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)]. Use a spring layout and display labels on the vertices. Add the graph to the scene.\n",
        "output": "from manim import *\\n\\nclass SpringLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6],\\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\\n            layout=\"spring\",\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Create a Manim scene that generates a tree layout graph with vertices [1, 2, 3, 4, 5, 6, 7] and edges [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]. Ensure the root vertex is 1 and display vertex labels.\n",
        "output": "from manim import *\\n\\nclass TreeLayout(Scene):\\n    def construct(self):\\n        graph = Graph(\\n            [1, 2, 3, 4, 5, 6, 7],\\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\\n            layout=\"tree\",\\n            layout_config={\"root_vertex\": 1},\\n            labels=True\\n        )\\n        self.add(graph)"
    },
    {
        "text_input": "Create a Manim scene that displays an axes with x-axis range from 0 to 10 and y-axis range from -2 to 6. Include numbers on the axes and set the y-axis to use log scaling with custom labels. Plot the function f(x) = x^2 from x = 0.001 to x = 10 without smoothing.\n",
        "output": "from manim import *\\n\\nclass LogScalingExample(Scene):\\n    def construct(self):\\n        ax = Axes(\\n            x_range=[0, 10, 1],\\n            y_range=[-2, 6, 1],\\n            tips=False,\\n            axis_config={\"include_numbers\": True},\\n            y_axis_config={\"scaling\": LogBase(custom_labels=True)},\\n        )\\n\\n        # x_min must be > 0 because log is undefined at 0.\\n        graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)\\n        self.add(ax, graph)"
    },
    {
        "text_input": "Create a Manim scene that displays axes with stealth tips (StealthTip) on both x-axis and y-axis.\n",
        "output": "from manim import *\\n\\nclass AxesWithDifferentTips(Scene):\\n    def construct(self):\\n        ax = Axes(axis_config={'tip_shape': StealthTip})\\n        self.add(ax)"
    },
    {
        "text_input": "Create a Manim scene that includes\nAn Axes object with coordinates displayed.\nA green dot positioned at coordinates (2, 2) relative to the axes.\nLines connecting the axes to the point (2, 2).\nA NumberPlane.\nA red dot positioned at coordinates (2, 2, 0) relative to the scene.\n",
        "output": "from manim import *\\n\\nclass CoordsToPointExample(Scene):\\n    def construct(self):\\n        ax = Axes().add_coordinates()\\n\\n        # a dot with respect to the axes\\n        dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)\\n        lines = ax.get_lines_to_point(ax.c2p(2,2))\\n\\n        # a dot with respect to the scene\\n        # the default plane corresponds to the coordinates of the scene.\\n        plane = NumberPlane()\\n        dot_scene = Dot((2,2,0), color=RED)\\n\\n        self.add(plane, dot_scene, ax, dot_axes, lines)"
    },
    {
        "text_input": "Create a Manim scene that displays an Axes object. Add axis labels for the x-axis and y-axis with \"x-axis\" scaled to 0.7 and \"y-axis\" scaled to 0.45.\n",
        "output": "from manim import *\\n\\nclass GetAxisLabelsExample(Scene):\\n    def construct(self):\\n        ax = Axes()\\n        labels = ax.get_axis_labels(\\n            Tex(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45)\\n        )\\n        self.add(ax, labels)"
    },
    {
        "text_input": "Create a Manim scene that includes:\n1. A NumberPlane centered with x-axis ranging from 0 to 7 and y-axis ranging from 0 to 5, with numbers included on the axes.\n2. Plot a line graph using the given x and y values: x = [0, 1.5, 2, 2.8, 4, 6.25] and y = [1, 3, 2.25, 4, 2.5, 1.75].\n   - Use a line color of GOLD_E.\n   - Style the vertices with a purple fill color and a stroke width of 3.\n   - Set the line's stroke width to 4.\n",
        "output": "from manim import *\\n\\nclass LineGraphExample(Scene):\\n    def construct(self):\\n        plane = NumberPlane(\\n            x_range = (0, 7),\\n            y_range = (0, 5),\\n            x_length = 7,\\n            axis_config={\"include_numbers\": True},\\n        )\\n        plane.center()\\n        line_graph = plane.plot_line_graph(\\n            x_values = [0, 1.5, 2, 2.8, 4, 6.25],\\n            y_values = [1, 3, 2.25, 4, 2.5, 1.75],\\n            line_color=GOLD_E,\\n            vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),\\n            stroke_width = 4,\\n        )\\n        self.add(plane, line_graph)"
    },
    {
        "text_input": "Create a Manim scene with an Axes showing x-axis range 0 to 10 (step 2), and add a circle at UR*2, display rounded coordinates at circle's right next to a dot.\n",
        "output": "from manim import *\\n\\nclass PointToCoordsExample(Scene):\\n    def construct(self):\\n        ax = Axes(x_range=[0, 10, 2]).add_coordinates()\\n        circ = Circle(radius=0.5).shift(UR * 2)\\n\\n        # get the coordinates of the circle with respect to the axes\\n        coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)\\n\\n        label = (\\n            Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)\\n        )\\n\\n        self.add(ax, circ, label, Dot(circ.get_right()))"
    },
    {
        "text_input": "Create a Manim scene that displays a ComplexPlane with coordinates. Place a yellow dot at the complex number 2+i and another yellow dot at -3-2i on the plane. Position the label \"2+i\" next to the first dot and \"-3-2i\" next to the second dot, both shifted up and right (UR) by 0.1 units.\n",
        "output": "from manim import *\\n\\nclass ComplexPlaneExample(Scene):\\n    def construct(self):\\n        plane = ComplexPlane().add_coordinates()\\n        self.add(plane)\\n        d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)\\n        d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)\\n        label1 = MathTex(\"2+i\").next_to(d1, UR, 0.1)\\n        label2 = MathTex(\"-3-2i\").next_to(d2, UR, 0.1)\\n        self.add(\\n            d1,\\n            label1,\\n            d2,\\n            label2,\\n        )"
    },
    {
        "text_input": "Create a Manim scene with an Axes showing x-axis range 0 to 1 (step 0.05) and y-axis range 0 to 1 (step 0.05), labels for x and y axes, plots for y=x^n and y=x^(1/n) for n=1, 1.5, 2, ..., 20 (white color, no smoothing for y=x^(1/n)), lines and label for point (1,1) in blue, a yellow dot at (1,1), and a title \"Graphs of y = x^(1/n) and y = x^n (n = 1, 2, 3, ..., 20)\" (font size 40).\n",
        "output": "from manim import *\\n\\nclass CoordSysExample(Scene):\\n    def construct(self):\\n        # the location of the ticks depends on the x_range and y_range.\\n        grid = Axes(\\n            x_range=[0, 1, 0.05],  # step size determines num_decimal_places.\\n            y_range=[0, 1, 0.05],\\n            x_length=9,\\n            y_length=5.5,\\n            axis_config={\\n                \"numbers_to_include\": np.arange(0, 1 + 0.1, 0.1),\\n                \"font_size\": 24,\\n            },\\n            tips=False,\\n        )\\n\\n        # Labels for the x-axis and y-axis.\\n        y_label = grid.get_y_axis_label(\"y\", edge=LEFT, direction=LEFT, buff=0.4)\\n        x_label = grid.get_x_axis_label(\"x\")\\n        grid_labels = VGroup(x_label, y_label)\\n\\n        graphs = VGroup()\\n        for n in np.arange(1, 20 + 0.5, 0.5):\\n            graphs += grid.plot(lambda x: x ** n, color=WHITE)\\n            graphs += grid.plot(\\n                lambda x: x ** (1 / n), color=WHITE, use_smoothing=False\\n            )\\n\\n        # Extra lines and labels for point (1,1)\\n        graphs += grid.get_horizontal_line(grid.c2p(1, 1, 0), color=BLUE)\\n        graphs += grid.get_vertical_line(grid.c2p(1, 1, 0), color=BLUE)\\n        graphs += Dot(point=grid.c2p(1, 1, 0), color=YELLOW)\\n        graphs += Tex(\"(1,1)\").scale(0.75).next_to(grid.c2p(1, 1, 0))\\n        title = Title(\\n            # spaces between braces to prevent SyntaxError\\n            r\"Graphs of $y=x^{ {1}\\over{n} }$ and $y=x^n (n=1,2,3,...,20)$\",\\n            include_underline=False,\\n            font_size=40,\\n        )\\n\\n        self.add(title, graphs, grid, grid_labels)"
    },
    {
        "text_input": "Create a Manim scene that displays an Axes object with x-axis ranging from -1 to 10 and y-axis ranging from -1 to 10, with a length of 9 units for x-axis and 6 units for y-axis. Plot the function f(x) = x in blue. Add a T_label at x = 4 with the label \"x-value\".\n",
        "output": "from manim import *\\n\\nclass TLabelExample(Scene):\\n    def construct(self):\\n        # defines the axes and linear function\\n        axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)\\n        func = axes.plot(lambda x: x, color=BLUE)\\n        # creates the T_label\\n        t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(\"x-value\"))\\n        self.add(axes, func, t_label)"
    },
    {
        "text_input": "Create a Manim scene with an Axes displaying coordinates, plot y = 2*sin(x) in dark blue, shade the area under the curve between x = \u03c0/2 and x = 3\u03c0/2 in green (opacity 1).\n",
        "output": "from manim import *\\n\\nclass GetAreaExample(Scene):\\n    def construct(self):\\n        ax = Axes().add_coordinates()\\n        curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)\\n        area = ax.get_area(\\n            curve,\\n            x_range=(PI / 2, 3 * PI / 2),\\n            color=(GREEN_B, GREEN_D),\\n            opacity=1,\\n        )\\n\\n        self.add(ax, curve, area)"
    },
    {
        "text_input": "Create a Manim scene with an Axes, plot y = sin(x) in light purple, and add a label \"\\(\\frac{\\pi}{2}\\)\" at x = \u03c0/2 with a dot, positioned upper right (UR).\n",
        "output": "from manim import *\\n\\nclass GetGraphLabelExample(Scene):\\n    def construct(self):\\n        ax = Axes()\\n        sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)\\n        label = ax.get_graph_label(\\n            graph=sin,\\n            label= MathTex(r\"\\frac{\\pi}{2}\"),\\n            x_val=PI / 2,\\n            dot=True,\\n            direction=UR,\\n        )\\n\\n        self.add(ax, sin, label)"
    },
    {
        "text_input": "Create a Manim scene with an Axes displaying coordinates, add a dot at (-4, 1.5), and draw a horizontal line passing through this point.\n",
        "output": "from manim import *\\n\\nclass GetHorizontalLineExample(Scene):\\n    def construct(self):\\n        ax = Axes().add_coordinates()\\n        point = ax.c2p(-4, 1.5)\\n\\n        dot = Dot(point)\\n        line = ax.get_horizontal_line(point, line_func=Line)\\n\\n        self.add(ax, line, dot)"
    },
    {
        "text_input": "Create a Manim scene with an Axes, place a circle at (-4, -1.5) with radius 0.5, show green lines to the circle's rightmost point and blue lines to its bottom-left corner.\n",
        "output": "from manim import *\\n\\nclass GetLinesToPointExample(Scene):\\n    def construct(self):\\n        ax = Axes()\\n        circ = Circle(radius=0.5).move_to([-4, -1.5, 0])\\n\\n        lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)\\n        lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)\\n        self.add(ax, lines_1, lines_2, circ)"
    },
    {
        "text_input": "Create a Manim scene with an Axes displaying y-axis range from -2 to 10. Plot the function y = 0.5 * x^2 - 0.5. Generate Riemann rectangles:\n- Right-sided rectangles for the function from x = -4 to x = -3 with dx = 0.25, using a gradient color (TEAL to DARK_BLUE).\n- Left-sided rectangles for the function from x = -1.5 to x = 1.5 with dx = 0.15, colored in YELLOW.\n- Riemann rectangles for a bounding line y = 1.5 * x from x = 4 to x = 5, constrained by the function, without signed area shown, using a gradient color (MAROON_A to PURPLE_D).\n",
        "output": "from manim import *\\n\\nclass GetRiemannRectanglesExample(Scene):\\n    def construct(self):\\n        ax = Axes(y_range=[-2, 10])\\n        quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)\\n\\n        # the rectangles are constructed from their top right corner.\\n        # passing an iterable to `color` produces a gradient\\n        rects_right = ax.get_riemann_rectangles(\\n            quadratic,\\n            x_range=[-4, -3],\\n            dx=0.25,\\n            color=(TEAL, BLUE_B, DARK_BLUE),\\n            input_sample_type=\"right\",\\n        )\\n\\n        # the colour of rectangles below the x-axis is inverted\\n        # due to show_signed_area\\n        rects_left = ax.get_riemann_rectangles(\\n            quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW\\n        )\\n\\n        bounding_line = ax.plot(\\n            lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]\\n        )\\n        bounded_rects = ax.get_riemann_rectangles(\\n            bounding_line,\\n            bounded_graph=quadratic,\\n            dx=0.15,\\n            x_range=[4, 5],\\n            show_signed_area=False,\\n            color=(MAROON_A, RED_B, PURPLE_D),\\n        )\\n\\n        self.add(\\n            ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects\\n        )"
    },
    {
        "text_input": "Create a Manim scene with an Axes displaying y-axis range from -1 to 7. Plot the function y = \\frac{1}{4}x^2 in blue. Generate a secant slope group:\n- Calculate secant slopes at x = 2.0 with dx = 1.0, displaying labels \"dx = 1.0\" for dx and \"dy\" for dy.\n- Use green for the dx line and red for the secant line, with a length of 4 units.\n",
        "output": "from manim import *\\n\\nclass GetSecantSlopeGroupExample(Scene):\\n    def construct(self):\\n        ax = Axes(y_range=[-1, 7])\\n        graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)\\n        slopes = ax.get_secant_slope_group(\\n            x=2.0,\\n            graph=graph,\\n            dx=1.0,\\n            dx_label=Tex(\"dx = 1.0\"),\\n            dy_label=\"dy\",\\n            dx_line_color=GREEN_B,\\n            secant_line_length=4,\\n            secant_line_color=RED_D,\\n        )\\n\\n        self.add(ax, graph, slopes)"
    },
    {
        "text_input": "Create a Manim scene that includes:\n1. An Axes object with coordinates displayed.\n2. Define a point at (-3.5, 2) on the axes.\n3. Display a dot at the defined point.\n4. Add a vertical dashed line passing through the point with a dashed ratio of 0.85.\n",
        "output": "from manim import *\\n\\nclass GetVerticalLineExample(Scene):\\n    def construct(self):\\n        ax = Axes().add_coordinates()\\n        point = ax.coords_to_point(-3.5, 2)\\n\\n        dot = Dot(point)\\n        line = ax.get_vertical_line(point, line_config={\"dashed_ratio\": 0.85})\\n\\n        self.add(ax, line, dot)"
    },
    {
        "text_input": "Create a Manim scene with an Axes displaying:\n1. x-axis range from 0 to 8 with step size 1, and y-axis range from -1 to 1 with step size 0.2, using a font size of 24 for the axis labels.\n2. Plot the curve y = sin(x) / e^2 * x on the axes.\n3. Draw 30 vertical blue lines from x = 0 to x = 4, intersecting the curve.\n",
        "output": "from manim import *\\n\\nclass GetVerticalLinesToGraph(Scene):\\n    def construct(self):\\n        ax = Axes(\\n            x_range=[0, 8.0, 1],\\n            y_range=[-1, 1, 0.2],\\n            axis_config={\"font_size\": 24},\\n        ).add_coordinates()\\n\\n        curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)\\n\\n        lines = ax.get_vertical_lines_to_graph(\\n            curve, x_range=[0, 4], num_lines=30, color=BLUE\\n        )\\n\\n        self.add(ax, curve, lines)"
    },
    {
        "text_input": "Create a Manim scene that includes:\n1. An Axes object with x-axis ranging from 0 to 8 and y-axis ranging from 0 to 5, with lengths 8 units and 5 units respectively.\n2. Display the x-axis label \"$x$-values\" scaled to 0.65, positioned at the bottom edge (edge=DOWN) and aligned downwards (direction=DOWN), with a buffer of 0.5 units.\n",
        "output": "from manim import *\\n\\nclass GetXAxisLabelExample(Scene):\\n    def construct(self):\\n        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\\n        x_label = ax.get_x_axis_label(\\n            Tex(\"$x$-values\").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5\\n        )\\n        self.add(ax, x_label)"
    },
    {
        "text_input": "Create a Manim scene that includes:\n1. An Axes object with x-axis ranging from 0 to 8 and y-axis ranging from 0 to 5, with lengths 8 units and 5 units respectively.\n2. Display the y-axis label \"$y$-values\" scaled to 0.65 and rotated 90 degrees, positioned at the left edge (edge=LEFT) and aligned leftwards (direction=LEFT), with a buffer of 0.3 units.\n",
        "output": "from manim import *\\n\\nclass GetYAxisLabelExample(Scene):\\n    def construct(self):\\n        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\\n        y_label = ax.get_y_axis_label(\\n            Tex(\"$y$-values\").scale(0.65).rotate(90 * DEGREES),\\n            edge=LEFT,\\n            direction=LEFT,\\n            buff=0.3,\\n        )\\n        self.add(ax, y_label)"
    },
    {
        "text_input": "Create a Manim scene that includes:\n1. An Axes object.\n2. Plot the curve y = cos(x) on the axes.\n3. Move a yellow square with side length 1 to the point on the cosine curve corresponding to x = \u03c0.\n",
        "output": "from manim import *\\n\\nclass InputToGraphPointExample(Scene):\\n    def construct(self):\\n        ax = Axes()\\n        curve = ax.plot(lambda x : np.cos(x))\\n\\n        # move a square to PI on the cosine curve.\\n        position = ax.input_to_graph_point(x=PI, graph=curve)\\n        sq = Square(side_length=1, color=YELLOW).move_to(position)\\n\\n        self.add(ax, curve, sq)"
    },
    {
        "text_input": "Create a Manim scene that includes:\n1. Three Axes objects with:\n   - First axis (ax_1) positioned in the upper left corner (UL) with x-axis range from 0.001 to 6 and y-axis range from -8 to 2, with dimensions 5 units wide and 3 units high, without tips.\n   - Second axis (ax_2) positioned in the upper right corner (UR), copied from ax_1.\n   - Third axis (ax_3) positioned at the bottom edge (DOWN), copied from ax_1.\n2. Plot three logarithmic curves on each axis:\n   - Curve 1 (curve_1) in pure red without adjustments.\n   - Curve 2 (curve_2) in orange with interpolation disabled (use_smoothing=False).\n   - Curve 3 (curve_3) in pure green with a finer x-axis step size (0.001) from 0.001 to 6.\n",
        "output": "from manim import *\\n\\nclass PlotExample(Scene):\\n    def construct(self):\\n        # construct the axes\\n        ax_1 = Axes(\\n            x_range=[0.001, 6],\\n            y_range=[-8, 2],\\n            x_length=5,\\n            y_length=3,\\n            tips=False,\\n        )\\n        ax_2 = ax_1.copy()\\n        ax_3 = ax_1.copy()\\n\\n        # position the axes\\n        ax_1.to_corner(UL)\\n        ax_2.to_corner(UR)\\n        ax_3.to_edge(DOWN)\\n        axes = VGroup(ax_1, ax_2, ax_3)\\n\\n        # create the logarithmic curves\\n        def log_func(x):\\n            return np.log(x)\\n\\n        # a curve without adjustments; poor interpolation.\\n        curve_1 = ax_1.plot(log_func, color=PURE_RED)\\n\\n        # disabling interpolation makes the graph look choppy as not enough\\n        # inputs are available\\n        curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)\\n\\n        # taking more inputs of the curve by specifying a step for the\\n        # x_range yields expected results, but increases rendering time.\\n        curve_3 = ax_3.plot(\\n            log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN\\n        )\\n\\n        curves = VGroup(curve_1, curve_2, curve_3)\\n\\n        self.add(axes, curves)"
    },
    {
        "text_input": "Create a Manim scene with an Axes, plot \\( \\frac{x^2 - 2}{3} \\) in red, and display its antiderivative graph in blue.\n",
        "output": "from manim import *\\n\\nclass AntiderivativeExample(Scene):\\n    def construct(self):\\n        ax = Axes()\\n        graph1 = ax.plot(\\n            lambda x: (x ** 2 - 2) / 3,\\n            color=RED,\\n        )\\n        graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)\\n        self.add(ax, graph1, graph2)"
    },
    {
        "text_input": "Create a Manim scene with a NumberPlane showing y-axis range from -1 to 7, plot x^2 in purple, its derivative 2x, display labels near x = -2 and x = 3 accordingly.\n",
        "output": "from manim import *\\n\\nclass DerivativeGraphExample(Scene):\\n    def construct(self):\\n        ax = NumberPlane(y_range=[-1, 7], background_line_style={\"stroke_opacity\": 0.4})\\n\\n        curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)\\n        curve_2 = ax.plot_derivative_graph(curve_1)\\n        curves = VGroup(curve_1, curve_2)\\n\\n        label_1 = ax.get_graph_label(curve_1, \"x^2\", x_val=-2, direction=DL)\\n        label_2 = ax.get_graph_label(curve_2, \"2x\", x_val=3, direction=RIGHT)\\n        labels = VGroup(label_1, label_2)\\n\\n        self.add(ax, curves, labels)"
    },
    {
        "text_input": "Create a Manim scene with an Axes object. Plot the implicit curve defined by the equation \\( y \\cdot (x - y)^2 - 4x - 8 = 0 \\) in blue.\n",
        "output": "from manim import *\\n\\nclass ImplicitExample(Scene):\\n    def construct(self):\\n        ax = Axes()\\n        a = ax.plot_implicit_curve(\\n            lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE\\n        )\\n        self.add(ax, a)"
    },
    {
        "text_input": "Create a Manim scene with an Axes object. Plot the parametric curve defined by:\n- x(t) = e * cos(t) * (1 - cos(t))\n- y(t) = e * sin(t) * (1 - cos(t))\n- z(t) = 0\nover the interval t from 0 to 2\u03c0, colored in \"#0FF1CE\".\n",
        "output": "from manim import *\\n\\nclass ParametricCurveExample(Scene):\\n    def construct(self):\\n        ax = Axes()\\n        cardioid = ax.plot_parametric_curve(\\n            lambda t: np.array(\\n                [\\n                    np.exp(1) * np.cos(t) * (1 - np.cos(t)),\\n                    np.exp(1) * np.sin(t) * (1 - np.cos(t)),\\n                    0,\\n                ]\\n            ),\\n            t_range=[0, 2 * PI],\\n            color=\"#0FF1CE\",\\n        )\\n        self.add(ax, cardioid)"
    },
    {
        "text_input": "Create a Manim scene with a PolarPlane. Plot the polar graph defined by \\( r(\\theta) = 2 \\sin(5\\theta) \\) over the interval \\( \\theta \\) from 0 to \\( 2\\pi \\), colored in orange.\n",
        "output": "from manim import *\\n\\nclass PolarGraphExample(Scene):\\n    def construct(self):\\n        plane = PolarPlane()\\n        r = lambda theta: 2 * np.sin(theta * 5)\\n        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)\\n        self.add(plane, graph)"
    },
    {
        "text_input": "Create a ThreeDScene with:\n- Camera orientation set to phi=75 degrees and theta=-60 degrees.\n- ThreeDAxes with x-axis range from -3 to 3, y-axis range from -3 to 3, and z-axis range from -5 to 5.\n- Plot a surface defined by the parametric function:\n  - x = u\n  - y = v\n  - z = 2 * sin(u) + 2 * cos(v)\n  over u from -3 to 3 and v from -3 to 3, using a resolution of 16, and colorscale ranging from BLUE to RED.\n",
        "output": "from manim import *\\n\\nclass PlotSurfaceExample(ThreeDScene):\\n    def construct(self):\\n        resolution_fa = 16\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)\\n        axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))\\n        def param_trig(u, v):\\n            x = u\\n            y = v\\n            z = 2 * np.sin(x) + 2 * np.cos(y)\\n            return z\\n        trig_plane = axes.plot_surface(\\n            param_trig,\\n            resolution=(resolution_fa, resolution_fa),\\n            u_range = (-3, 3),\\n            v_range = (-3, 3),\\n            colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],\\n            )\\n        self.add(axes, trig_plane)"
    },
    {
        "text_input": "Create a Manim scene with:\n- A PolarPlane configured with azimuth units in \"PI radians\" and size 6.\n- Convert the polar coordinates (3, \u03c0/4) to Cartesian coordinates and display the resulting vector on the scene.\n",
        "output": "from manim import *\\n\\nclass PolarToPointExample(Scene):\\n    def construct(self):\\n        polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)\\n        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))\\n        self.add(polarplane_pi)\\n        self.add(polartopoint_vector)"
    },
    {
        "text_input": "Create a Manim scene with a NumberPlane:\n- Configure the background lines with stroke color TEAL, stroke width 4, and stroke opacity 0.6.\n",
        "output": "from manim import *\\n\\nclass NumberPlaneExample(Scene):\\n    def construct(self):\\n        number_plane = NumberPlane(\\n            background_line_style={\\n                \"stroke_color\": TEAL,\\n                \"stroke_width\": 4,\\n                \"stroke_opacity\": 0.6\\n            }\\n        )\\n        self.add(number_plane)"
    },
    {
        "text_input": "Create a Manim scene with:\n- A NumberPlane centered at LEFT * 3 with x-axis range from -4 to 11 and y-axis range from -3 to 3, x-axis length 5 units and y-axis length 2 units.\n- Another NumberPlane centered at RIGHT * 3 with x-axis range from -4 to 11, x-axis length 5 units, and y-axis length 4 units.\n",
        "output": "from manim import *\\n\\nclass NumberPlaneScaled(Scene):\\n    def construct(self):\\n        number_plane = NumberPlane(\\n            x_range=(-4, 11, 1),\\n            y_range=(-3, 3, 1),\\n            x_length=5,\\n            y_length=2,\\n        ).move_to(LEFT*3)\\n\\n        number_plane_scaled_y = NumberPlane(\\n            x_range=(-4, 11, 1),\\n            x_length=5,\\n            y_length=4,\\n        ).move_to(RIGHT*3)\\n\\n        self.add(number_plane)\\n        self.add(number_plane_scaled_y)"
    },
    {
        "text_input": "Create a Manim scene with a PolarPlane:\n- Configure the azimuth units as \"PI radians\", size 6.\n- Set azimuth label font size to 33.6 and radius font size to 33.6.\n- Add coordinates to the PolarPlane.\n",
        "output": "from manim import *\\n\\nclass PolarPlaneExample(Scene):\\n    def construct(self):\\n        polarplane_pi = PolarPlane(\\n            azimuth_units=\"PI radians\",\\n            size=6,\\n            azimuth_label_font_size=33.6,\\n            radius_config={\"font_size\": 33.6},\\n        ).add_coordinates()\\n        self.add(polarplane_pi)"
    },
    {
        "text_input": "Create a ThreeDScene with:\n- Camera orientation set to phi=2*PI/5 and theta=PI/5.\n- ThreeDAxes displayed in the scene.\n- Axis labels for x-axis scaled to 0.7, y-axis scaled to 0.45, and z-axis scaled to 0.45.\n",
        "output": "from manim import *\\n\\nclass GetAxisLabelsExample(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\\n        axes = ThreeDAxes()\\n        labels = axes.get_axis_labels(\\n            Text(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45), Text(\"z-axis\").scale(0.45)\\n        )\\n        self.add(axes, labels)"
    },
    {
        "text_input": "Create a ThreeDScene with:\n- ThreeDAxes displayed in the scene.\n- Set the camera orientation to phi=2*PI/5 and theta=PI/5.\n- Add the y-axis label scaled with LaTeX expression \"$y$-label\".\n",
        "output": "from manim import *\\n\\nclass GetYAxisLabelExample(ThreeDScene):\\n    def construct(self):\\n        ax = ThreeDAxes()\\n        lab = ax.get_y_axis_label(Tex(\"$y$-label\"))\\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\\n        self.add(ax, lab)"
    },
    {
        "text_input": "Create a ThreeDScene with ThreeDAxes, set camera orientation to phi=2*PI/5 and theta=PI/5, add z-axis label scaled with LaTeX expression \"$z$-label\".\n",
        "output": "from manim import *\\n\\nclass GetZAxisLabelExample(ThreeDScene):\\n    def construct(self):\\n        ax = ThreeDAxes()\\n        lab = ax.get_z_axis_label(Tex(\"$z$-label\"))\\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\\n        self.add(ax, lab)"
    },
    {
        "text_input": "Create a Manim scene displaying FunctionGraphs: cos(t) + 0.5 * cos(7*t) + (1/7) * cos(14*t) in red, sin(t) + 0.5 * sin(7*t) + (1/7) * sin(14*t) in blue, and sin(t) + 0.5 * sin(7*t) + (1/7) * sin(14*t) with x-range [-4, 4], in green, moved to [0, 1, 0].\n",
        "output": "from manim import *\\n\\nclass ExampleFunctionGraph(Scene):\\n    def construct(self):\\n        cos_func = FunctionGraph(\\n            lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),\\n            color=RED,\\n        )\\n\\n        sin_func_1 = FunctionGraph(\\n            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\\n            color=BLUE,\\n        )\\n\\n        sin_func_2 = FunctionGraph(\\n            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\\n            x_range=[-4, 4],\\n            color=GREEN,\\n        ).move_to([0, 1, 0])\\n\\n        self.add(cos_func, sin_func_1, sin_func_2)"
    },
    {
        "text_input": "Create a Manim scene displaying NumberPlane and an ImplicitFunction graph in yellow defined by the equation x * y ** 2 - x ** 2 * y - 2.\n",
        "output": "from manim import *\\n\\nclass ImplicitFunctionExample(Scene):\\n    def construct(self):\\n        graph = ImplicitFunction(\\n            lambda x, y: x * y ** 2 - x ** 2 * y - 2,\\n            color=YELLOW\\n        )\\n        self.add(NumberPlane(), graph)"
    },
    {
        "text_input": "Create a Manim scene displaying NumberPlane and an ImplicitFunction graph colored yellow, defined by the equation x * y ** 2 - x ** 2 * y - 2.\n",
        "output": "from manim import *\\n\\nclass ImplicitFunctionExample(Scene):\\n    def construct(self):\\n        graph = ImplicitFunction(\\n            lambda x, y: x * y ** 2 - x ** 2 * y - 2,\\n            color=YELLOW\\n        )\\n        self.add(NumberPlane(), graph)"
    },
    {
        "text_input": "Create a Manim scene with ParametricFunction(func=lambda t: (np.sin(2*t), np.sin(3*t), 0), t_range=(0, TAU), fill_opacity=0).set_color(RED).scale(3).\n",
        "output": "from manim import *\\n\\nclass PlotParametricFunction(Scene):\\n    def func(self, t):\\n        return (np.sin(2 * t), np.sin(3 * t), 0)\\n\\n    def construct(self):\\n        func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)\\n        self.add(func.scale(3))"
    },
    {
        "text_input": "Create a ThreeDScene in Manim with:\n- Display ThreeDAxes.\n- Add a ParametricFunction representing a spring-like curve defined by lambda u: (1.2 * np.cos(u), 1.2 * np.sin(u), u * 0.05).\n- Color the curve in red over the range from -3*TAU to 5*TAU with a step size of 0.01.\n- Set shade_in_3d=True for the ParametricFunction.\n- Adjust the camera orientation to phi=80 degrees and theta=-60 degrees.\n- End scene after displaying.\n",
        "output": "from manim import *\\n\\nclass ThreeDParametricSpring(ThreeDScene):\\n    def construct(self):\\n        curve1 = ParametricFunction(\\n            lambda u: (\\n                1.2 * np.cos(u),\\n                1.2 * np.sin(u),\\n                u * 0.05\\n            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)\\n        ).set_shade_in_3d(True)\\n        axes = ThreeDAxes()\\n        self.add(axes, curve1)\\n        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)\\n        self.wait()"
    },
    {
        "text_input": "Write Manim code to plot a discontinuous function on two separate number planes. Use a lambda function to define the function f(x) = (x ** 2 - 2) / (x ** 2 - 4). Plot the function on ax1 without specifying discontinuities, marked in red, and plot it on ax2 with discontinuities at x = -2 and x = 2, using a tolerance of 0.1, marked in green. Arrange ax1 and ax2 in a vertical group and display both plots simultaneously.",
        "output": "from manim import *\\n\\nclass DiscontinuousExample(Scene):\\n    def construct(self):\\n        ax1 = NumberPlane((-3, 3), (-4, 4))\\n        ax2 = NumberPlane((-3, 3), (-4, 4))\\n        VGroup(ax1, ax2).arrange()\\n        discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)\\n        incorrect = ax1.plot(discontinuous_function, color=RED)\\n        correct = ax2.plot(\\n            discontinuous_function,\\n            discontinuities=[-2, 2],  # discontinuous points\\n            dt=0.1,  # left and right tolerance of discontinuity\\n            color=GREEN,\\n        )\\n        self.add(ax1, ax2, incorrect, correct)"
    },
    {
        "text_input": "Create a Manim scene to display multiple number lines arranged vertically. Define four NumberLine objects: l0, l1, l2, and l3, each with different configurations:\n\nl0: Range from -10 to 10 with step 2, length 10, blue color, numbers included, labels directed upwards.\nl1: Range from -10 to 10 with step 2, unit size 0.5, elongated ticks at -2 and 4, font size 24, with number at index 8 colored red.\nl2: Range from -2.5 to 3.0 with step 0.5, length 12, displaying numbers with 2 decimal places.\nl3: Range from -5 to 6 with step 1, length 6, tip included, numbers included, rotated by 10 degrees.\nArrange these NumberLine objects vertically in a group with 1 unit of spacing between them and display them in the scene.",
        "output": "from manim import *\\n\\nclass NumberLineExample(Scene):\\n    def construct(self):\\n        l0 = NumberLine(\\n            x_range=[-10, 10, 2],\\n            length=10,\\n            color=BLUE,\\n            include_numbers=True,\\n            label_direction=UP,\\n        )\\n\\n        l1 = NumberLine(\\n            x_range=[-10, 10, 2],\\n            unit_size=0.5,\\n            numbers_with_elongated_ticks=[-2, 4],\\n            include_numbers=True,\\n            font_size=24,\\n        )\\n        num6 = l1.numbers[8]\\n        num6.set_color(RED)\\n\\n        l2 = NumberLine(\\n            x_range=[-2.5, 2.5 + 0.5, 0.5],\\n            length=12,\\n            decimal_number_config={\"num_decimal_places\": 2},\\n            include_numbers=True,\\n        )\\n\\n        l3 = NumberLine(\\n            x_range=[-5, 5 + 1, 1],\\n            length=6,\\n            include_tip=True,\\n            include_numbers=True,\\n            rotation=10 * DEGREES,\\n        )\\n\\n        line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)\\n        self.add(line_group)"
    },
    {
        "text_input": "Implement a Manim scene displaying a bar chart with specific configurations. Define a BarChart object named chart with the following parameters:\n\nValues: [-5, 40, -10, 20, -3]\nBar names: [\"one\", \"two\", \"three\", \"four\", \"five\"]\nY-axis range: from -20 to 50 with steps of 10\nY-axis length: 6 units\nX-axis length: 10 units\nX-axis configuration with a font size of 36\nAdditionally, retrieve the bar labels for the chart using get_bar_labels method with a font size of 48 and display both the chart and its labels in the scene.",
        "output": "from manim import *\\n\\nclass BarChartExample(Scene):\\n    def construct(self):\\n        chart = BarChart(\\n            values=[-5, 40, -10, 20, -3],\\n            bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],\\n            y_range=[-20, 50, 10],\\n            y_length=6,\\n            x_length=10,\\n            x_axis_config={\"font_size\": 36},\\n        )\\n\\n        c_bar_lbls = chart.get_bar_labels(font_size=48)\\n\\n        self.add(chart, c_bar_lbls)"
    },
    {
        "text_input": "Create a Manim scene demonstrating how to dynamically change bar values in a bar chart. Define a list values containing the numbers from -10 to 10. Initialize a BarChart object named chart with these values and configure it with:\n\nY-axis range from -10 to 10 with steps of 2.\nY-axis configuration with a font size of 24.\nAdd the chart to the scene. Then, change the bar values of the chart to the reverse of values using change_bar_values method. Display the updated bar labels with a font size of 24.",
        "output": "from manim import *\\n\\nclass ChangeBarValuesExample(Scene):\\n    def construct(self):\\n        values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]\\n\\n        chart = BarChart(\\n            values,\\n            y_range=[-10, 10, 2],\\n            y_axis_config={\"font_size\": 24},\\n        )\\n        self.add(chart)\\n\\n        chart.change_bar_values(list(reversed(values)))\\n        self.add(chart.get_bar_labels(font_size=24))"
    },
    {
        "text_input": "Implement a Manim scene displaying a bar chart and its corresponding bar labels. Define a BarChart object named chart with the following parameters:\n\nValues: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nY-axis range: from 0 to 10 with steps of 1\nRetrieve the bar labels for the chart using get_bar_labels method with the following configurations:\n\nLabel color: WHITE\nLabel constructor: MathTex\nFont size: 36\nDisplay both the chart and its labels in the scene.",
        "output": "from manim import *\\n\\nclass GetBarLabelsExample(Scene):\\n    def construct(self):\\n        chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])\\n\\n        c_bar_lbls = chart.get_bar_labels(\\n            color=WHITE, label_constructor=MathTex, font_size=36\\n        )\\n\\n        self.add(chart, c_bar_lbls)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of SampleSpace objects with different configurations. Define three SampleSpace objects named poly1, poly2, and poly3 with the following parameters:\n\npoly1: Default parameters with a stroke width of 15 and fill opacity of 1.\npoly2: Width of 5 units, height of 3 units, stroke width of 5, and fill opacity of 0.5.\npoly3: Width of 2 units, height of 2 units, stroke width of 5, and fill opacity of 0.1. Additionally, divide poly3 vertically into three parts using divide_vertically method with parameters: division points [0.37, 0.13, 0.5], colors [BLACK, WHITE, GRAY], and vector direction RIGHT.\nArrange these SampleSpace objects in a vertical group and display them in the scene.",
        "output": "from manim import *\\n\\nclass ExampleSampleSpace(Scene):\\n    def construct(self):\\n        poly1 = SampleSpace(stroke_width=15, fill_opacity=1)\\n        poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)\\n        poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)\\n        poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)\\n        poly_group = VGroup(poly1, poly2, poly3).arrange()\\n        self.add(poly_group)"
    },
    {
        "text_input": "Implement a Manim scene demonstrating the use of DecimalMatrix to display a matrix with decimal values. Define a DecimalMatrix object named m0 with the following parameters:\n\nMatrix data: [[3.456, 2.122], [33.2244, 12]]\nConfiguration for elements: Number of decimal places set to 2 using element_to_mobject_config.\nLeft bracket: \"{\"\nRight bracket: \"}\"\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass DecimalMatrixExample(Scene):\\n    def construct(self):\\n        m0 = DecimalMatrix(\\n            [[3.456, 2.122], [33.2244, 12]],\\n            element_to_mobject_config={\"num_decimal_places\": 2},\\n            left_bracket=\"\\{\",\\n            right_bracket=\"\\}\")\\n        self.add(m0)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of IntegerMatrix to display a matrix with integer values. Define an IntegerMatrix object named m0 with the following parameters:\n\nMatrix data: [[3.7, 2], [42.2, 12]] (Note: The values will be automatically converted to integers)\nLeft bracket: \"(\"\nRight bracket: \")\"\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass IntegerMatrixExample(Scene):\\n    def construct(self):\\n        m0 = IntegerMatrix(\\n            [[3.7, 2], [42.2, 12]],\\n            left_bracket=\"(\",\\n            right_bracket=\")\")\\n        self.add(m0)"
    },
    {
        "text_input": "Create a Manim scene showcasing various Matrix configurations. Define several Matrix objects (m0 to m5) with different parameters:\n\nm0: Matrix with data [[2, \"\\pi\"], [-1, 1]].\nm1: Matrix with data [[2, 0, 4], [-1, 1, 5]], configured with:\nVertical buffer (v_buff): 1.3\nHorizontal buffer (h_buff): 0.8\nSmall buffer for horizontal bracket (bracket_h_buff): SMALL_BUFF\nSmall buffer for vertical bracket (bracket_v_buff): SMALL_BUFF\nLeft bracket: \"{\"\nRight bracket: \"}\"\nAdded SurroundingRectangle around the second column.\nm2: Matrix with data [[2, 1], [-1, 3]], aligned to the upper-left corner (element_alignment_corner=UL), with:\nLeft bracket: \"(\"\nRight bracket: \")\"\nm3: Matrix with data [[2, 1], [-1, 3]], with:\nLeft bracket: \"\\langle\"\nRight bracket: \"\\rangle\"\nm4: Matrix with data [[2, 1], [-1, 3]], with the first column colored red and the second column colored green using set_column_colors.\nm5: Matrix with data [[2, 1], [-1, 3]], with the first row colored red and the second row colored green using set_row_colors.\nArrange all matrices (m0 to m5) in a grid layout with a buffer of 2 units between them and add them to the scene.",
        "output": "from manim import *\\n\\nclass MatrixExamples(Scene):\\n    def construct(self):\\n        m0 = Matrix([[2, \"\\pi\"], [-1, 1]])\\n        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\\n            v_buff=1.3,\\n            h_buff=0.8,\\n            bracket_h_buff=SMALL_BUFF,\\n            bracket_v_buff=SMALL_BUFF,\\n            left_bracket=\"\\{\",\\n            right_bracket=\"\\}\")\\n        m1.add(SurroundingRectangle(m1.get_columns()[1]))\\n        m2 = Matrix([[2, 1], [-1, 3]],\\n            element_alignment_corner=UL,\\n            left_bracket=\"(\",\\n            right_bracket=\")\")\\n        m3 = Matrix([[2, 1], [-1, 3]],\\n            left_bracket=\"\\\\langle\",\\n            right_bracket=\"\\\\rangle\")\\n        m4 = Matrix([[2, 1], [-1, 3]],\\n        ).set_column_colors(RED, GREEN)\\n        m5 = Matrix([[2, 1], [-1, 3]],\\n        ).set_row_colors(RED, GREEN)\\n        g = Group(\\n            m0,m1,m2,m3,m4,m5\\n        ).arrange_in_grid(buff=2)\\n        self.add(g)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of background rectangles with Matrix objects. Define several Matrix objects (m0, m1, m2) with different configurations:\n\nbackground: Create a Rectangle scaled to 3.2 units, with opacity set to 0.5, and colored with a gradient using TEAL, RED, and YELLOW.\nm0: Matrix with data [[12, -30], [-1, 15]], with background rectangles added to entries (add_background_rectangles_to_entries=True).\nm1: Matrix with data [[2, 0], [-1, 1]], with a background rectangle included around the entire matrix (include_background_rectangle=True).\nm2: Regular Matrix with data [[12, -30], [-1, 15]].\nArrange all matrices (m0, m1, m2) in a horizontal group with a buffer of 2 units between them and add them to the scene along with the background rectangle.",
        "output": "from manim import *\\n\\nclass BackgroundRectanglesExample(Scene):\\n    def construct(self):\\n        background= Rectangle().scale(3.2)\\n        background.set_fill(opacity=.5)\\n        background.set_color([TEAL, RED, YELLOW])\\n        self.add(background)\\n        m0 = Matrix([[12, -30], [-1, 15]],\\n            add_background_rectangles_to_entries=True)\\n        m1 = Matrix([[2, 0], [-1, 1]],\\n            include_background_rectangle=True)\\n        m2 = Matrix([[12, -30], [-1, 15]])\\n        g = Group(m0, m1, m2).arrange(buff=2)\\n        self.add(g)"
    },
    {
        "text_input": "Implement a Manim scene demonstrating the use of get_brackets method with Matrix objects to retrieve brackets around matrix entries. Define a Matrix object named m0 with the following data:\n\nMatrix data: [[\"\\pi\", 3], [1, 5]]\nUse the get_brackets method to obtain the brackets around matrix entries (bra). Set the colors of the brackets to BLUE and GREEN respectively.\n\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass GetBracketsExample(Scene):\\n    def construct(self):\\n        m0 = Matrix([[\"\\pi\", 3], [1, 5]])\\n        bra = m0.get_brackets()\\n        colors = [BLUE, GREEN]\\n        for k in range(len(colors)):\\n            bra[k].set_color(colors[k])\\n        self.add(m0)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of get_columns method with Matrix objects to manipulate specific columns. Define a Matrix object named m0 with the following data:\n\nMatrix data: [[\"\\pi\", 3], [1, 5]]\nAdd a SurroundingRectangle around the second column of the matrix using m0.get_columns()[1].\n\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass GetColumnsExample(Scene):\\n    def construct(self):\\n        m0 = Matrix([[\"\\pi\", 3], [1, 5]])\\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\\n        self.add(m0)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of get_entries method with Matrix objects to manipulate specific entries. Define a Matrix object named m0 with the following data:\n\nMatrix data: [[2, 3], [1, 5]]\nRetrieve the entries of the matrix using m0.get_entries(). Set the colors of the entries to BLUE, GREEN, YELLOW, and RED respectively.\n\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass GetEntriesExample(Scene):\\n    def construct(self):\\n        m0 = Matrix([[2, 3], [1, 5]])\\n        ent = m0.get_entries()\\n        colors = [BLUE, GREEN, YELLOW, RED]\\n        for k in range(len(colors)):\\n            ent[k].set_color(colors[k])\\n        self.add(m0)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of get_rows method with Matrix objects to manipulate specific rows. Define a Matrix object named m0 with the following data:\n\nMatrix data: [[\"\\pi\", 3], [1, 5]]\nAdd a SurroundingRectangle around the second row of the matrix using m0.get_rows()[1].\n\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass GetRowsExample(Scene):\\n    def construct(self):\\n        m0 = Matrix([[\"\\pi\", 3], [1, 5]])\\n        m0.add(SurroundingRectangle(m0.get_rows()[1]))\\n        self.add(m0)"
    },
    {
        "text_input": "Implement a Manim scene demonstrating the use of set_column_colors method with Matrix objects to set colors for specific columns. Define a Matrix object named m0 with the following data:\n\nMatrix data: [[\"\\pi\", 1], [-1, 3]]\nUse the set_column_colors method to set the colors of the columns:\n\nFirst column: RED\nSecond column: BLUE\nGeneral color for the rows: GREEN\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass SetColumnColorsExample(Scene):\\n    def construct(self):\\n        m0 = Matrix([[\"\\pi\", 1], [-1, 3]],\\n        ).set_column_colors([RED,BLUE], GREEN)\\n        self.add(m0)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of set_row_colors method with Matrix objects to set colors for specific rows. Define a Matrix object named m0 with the following data:\n\nMatrix data: [[\"\\pi\", 1], [-1, 3]]\nUse the set_row_colors method to set the colors of the rows:\n\nFirst row: RED\nSecond row: BLUE\nGeneral color for the columns: GREEN\nAdd the matrix m0 to the scene.",
        "output": "from manim import *\\n\\nclass SetRowColorsExample(Scene):\\n    def construct(self):\\n        m0 = Matrix([[\"\\pi\", 1], [-1, 3]],\\n        ).set_row_colors([RED,BLUE], GREEN)\\n        self.add(m0)"
    },
    {
        "text_input": "Create a Manim scene demonstrating the use of MobjectMatrix to display a matrix of various Mobjects. Define a MobjectMatrix object named m0 with the following data:\n\nMatrix containing the following Mobjects:\na: Circle scaled to 0.3\nb: Square scaled to 0.3\nc: MathTex(\"\\pi\") scaled to 2\nd: Star scaled to 0.3\nAdd the m0 matrix to the scene.",
        "output": "from manim import *\\n\\nclass MobjectMatrixExample(Scene):\\n    def construct(self):\\n        a = Circle().scale(0.3)\\n        b = Square().scale(0.3)\\n        c = MathTex(\"\\pi\").scale(2)\\n        d = Star().scale(0.3)\\n        m0 = MobjectMatrix([[a, b], [c, d]])\\n        self.add(m0)"
    },
    {
        "text_input": "Generate a 3D scene with a Dodecahedron object, setting the camera orientation to 75 degrees for phi and 30 degrees for theta.",
        "output": "from manim import *\\n\\nclass DodecahedronScene(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        obj = Dodecahedron()\\n        self.add(obj)"
    },
    {
        "text_input": "Generate a 3D scene with an Icosahedron object, setting the camera orientation to 75 degrees for phi and 30 degrees for theta.",
        "output": "from manim import *\\n\\nclass IcosahedronScene(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        obj = Icosahedron()\\n        self.add(obj)"
    },
    {
        "text_input": "Generate a 3D scene with an Octahedron object, setting the camera orientation to 75 degrees for phi and 30 degrees for theta.",
        "output": "from manim import *\\n\\nclass OctahedronScene(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        obj = Octahedron()\\n        self.add(obj)"
    },
    {
        "text_input": "Generate a 3D scene with an Octahedron object with an edge length of 3, setting the camera orientation to 75 degrees for phi and 30 degrees for theta, and customize the colors of the first vertex to red and the third face to yellow.",
        "output": "from manim import *\\n\\nclass PolyhedronSubMobjects(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        octahedron = Octahedron(edge_length = 3)\\n        octahedron.graph[0].set_color(RED)\\n        octahedron.faces[2].set_color(YELLOW)\\n        self.add(octahedron)"
    },
    {
        "text_input": "Generate a 3D scene with a Tetrahedron object, setting the camera orientation to 75 degrees for phi and 30 degrees for theta.",
        "output": "from manim import *\\n\\nclass TetrahedronScene(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        obj = Tetrahedron()\\n        self.add(obj)"
    },
    {
        "text_input": "Create a scene displaying an image loaded from \"path_to_your_image.png\", scaled to a resolution of 1080, using bicubic resampling algorithm, and then animating its shift to the left by 2 units.",
        "output": "from manim import *\\n\\nclass DisplayImage(Scene):\\n    def construct(self):\\n        # Load an image file\\n        image_path = \"path_to_your_image.png\"  # Replace with your image path\\n        image = ImageMobject(image_path, scale_to_resolution=1080)  # Scale image to resolution\\n\\n        # Optional: Set a different resampling algorithm\\n        image.set_resampling_algorithm(Resampling.BICUBIC)\\n\\n        # Add the image to the scene\\n        self.add(image)\\n\\n        # Example animation: move the image\\n        self.play(image.animate.shift(LEFT * 2))\\n\\n        self.wait(1)\\n"
    },
    {
        "text_input": "Create a scene displaying an image constructed from a 2x4 array of pixel intensity values (np.uint8), with specified pixel values, and set the height of the image to 7 units.",
        "output": "from manim import *\\n\\nclass ImageFromArray(Scene):\\n    def construct(self):\\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\\n                                       [255, 0, 5, 33]]))\\n        image.height = 7\\n        self.add(image)"
    },
    {
        "text_input": "Create a scene demonstrating image interpolation using different algorithms (nearest, lanczos, linear, cubic, box) on a 4x4 image matrix with specific intensity values, each annotated with its respective interpolation algorithm label positioned above it.",
        "output": "from manim import *\\n\\nclass ImageInterpolationEx(Scene):\\n    def construct(self):\\n        img = ImageMobject(np.uint8([[63, 0, 0, 0],\\n                                        [0, 127, 0, 0],\\n                                        [0, 0, 191, 0],\\n                                        [0, 0, 0, 255]\\n                                        ]))\\n\\n        img.height = 2\\n        img1 = img.copy()\\n        img2 = img.copy()\\n        img3 = img.copy()\\n        img4 = img.copy()\\n        img5 = img.copy()\\n\\n        img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\\n        img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"lanczos\"])\\n        img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"linear\"])\\n        img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"cubic\"])\\n        img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"box\"])\\n        img1.add(Text(\"nearest\").scale(0.5).next_to(img1,UP))\\n        img2.add(Text(\"lanczos\").scale(0.5).next_to(img2,UP))\\n        img3.add(Text(\"linear\").scale(0.5).next_to(img3,UP))\\n        img4.add(Text(\"cubic\").scale(0.5).next_to(img4,UP))\\n        img5.add(Text(\"box\").scale(0.5).next_to(img5,UP))\\n\\n        x= Group(img1,img2,img3,img4,img5)\\n        x.arrange()\\n        self.add(x)"
    },
    {
        "text_input": "Create a scene demonstrating the use of PGroup to organize and display three different PointCloudDot objects with varying radius, density, stroke width, and colors, positioned accordingly on the screen.",
        "output": "from manim import *\\n\\nclass PgroupExample(Scene):\\n    def construct(self):\\n\\n        p1 = PointCloudDot(radius=1, density=20, color=BLUE)\\n        p1.move_to(4.5 * LEFT)\\n        p2 = PointCloudDot()\\n        p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)\\n        p3.move_to(4.5 * RIGHT)\\n        pList = PGroup(p1, p2, p3)\\n\\n        self.add(pList)"
    },
    {
        "text_input": "Create a scene demonstrating the use of PGroup to organize and display a collection of PointCloudDot objects, each scaled differently by thinning out the points based on a scale factor from 1 to 9. The objects are arranged in a grid layout on the screen.",
        "output": "from manim import *\\n\\nclass PMobjectExample(Scene):\\n    def construct(self):\\n\\n        pG = PGroup()  # This is just a collection of PMobject's\\n\\n        # As the scale factor increases, the number of points\\n        # removed increases.\\n        for sf in range(1, 9 + 1):\\n            p = PointCloudDot(density=20, radius=1).thin_out(sf)\\n            # PointCloudDot is a type of PMobject\\n            # and can therefore be added to a PGroup\\n            pG.add(p)\\n\\n        # This organizes all the shapes in a grid.\\n        pG.arrange_in_grid()\\n\\n        self.add(pG)"
    },
    {
        "text_input": "Create a scene demonstrating the creation of 400 random points using the Point class from Manim. Each point is positioned randomly within specified ranges along the x and y axes, with colors chosen randomly from a predefined list.",
        "output": "from manim import *\\n\\nclass ExamplePoint(Scene):\\n    def construct(self):\\n        colorList = [RED, GREEN, BLUE, YELLOW]\\n        for i in range(200):\\n            point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\\n            self.add(point)\\n        for i in range(200):\\n            point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\\n            self.add(point)\\n        self.add(point)"
    },
    {
        "text_input": "Create a scene demonstrating the usage of PointCloudDot from Manim, creating three instances with different configurations: one with a red color, another with increased stroke width and radius, and the third with reduced density of points. Display all instances arranged horizontally on the screen.",
        "output": "from manim import *\\n\\nclass PointCloudDotExample(Scene):\\n    def construct(self):\\n        cloud_1 = PointCloudDot(color=RED)\\n        cloud_2 = PointCloudDot(stroke_width=4, radius=1)\\n        cloud_3 = PointCloudDot(density=15)\\n\\n        group = Group(cloud_1, cloud_2, cloud_3).arrange()\\n        self.add(group)"
    },
    {
        "text_input": "Create a scene demonstrating the usage of ComplexPlane and PointCloudDot from Manim. Display a complex plane and a red-colored PointCloudDot on the plane. Then, animate the PointCloudDot by applying a complex function transformation, specifically the exponential function (np.exp(z)).",
        "output": "from manim import *\\n\\nclass PointCloudDotExample2(Scene):\\n    def construct(self):\\n        plane = ComplexPlane()\\n        cloud = PointCloudDot(color=RED)\\n        self.add(\\n            plane, cloud\\n        )\\n        self.wait()\\n        self.play(\\n            cloud.animate.apply_complex_function(lambda z: np.exp(z))\\n        )"
    },
    {
        "text_input": "Create a scene displaying three rows of DashedVMobject instances: circles in the top row with increasing dashes (1 to 11), circles in the middle row with dashed ratios from 1/11 to 1, and two FunctionGraph objects in the bottom row depicting t^5 with 6 evenly and unevenly spaced dashes.",
        "output": "from manim import *\\n\\nclass DashedVMobjectExample(Scene):\\n    def construct(self):\\n        r = 0.5\\n\\n        top_row = VGroup()  # Increasing num_dashes\\n        for dashes in range(1, 12):\\n            circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)\\n            top_row.add(circ)\\n\\n        middle_row = VGroup()  # Increasing dashed_ratio\\n        for ratio in np.arange(1 / 11, 1, 1 / 11):\\n            circ = DashedVMobject(\\n                Circle(radius=r, color=WHITE), dashed_ratio=ratio\\n            )\\n            middle_row.add(circ)\\n\\n        func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)\\n        func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)\\n        func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)\\n        bottom_row = VGroup(func_even,func_stretched)\\n\\n        top_row.arrange(buff=0.3)\\n        middle_row.arrange()\\n        bottom_row.arrange(buff=1)\\n        everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)\\n        self.add(everything)"
    },
    {
        "text_input": "Generate the code to demonstrate the usage of VDict in manim, including creating a VDict from a list of tuples with mobjects, adding, accessing, and removing submobjects by keys, animating transformations, reassigning submobjects, and creating VDict from an existing Python dictionary and using zip.\n",
        "output": "from manim import *\\n\\nclass ShapesWithVDict(Scene):\\n    def construct(self):\\n        square = Square().set_color(RED)\\n        circle = Circle().set_color(YELLOW).next_to(square, UP)\\n\\n        # create dict from list of tuples each having key-mobject pair\\n        pairs = [(\"s\", square), (\"c\", circle)]\\n        my_dict = VDict(pairs, show_keys=True)\\n\\n        # display it just like a VGroup\\n        self.play(Create(my_dict))\\n        self.wait()\\n\\n        text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)\\n\\n        # add a key-value pair by wrapping it in a single-element list of tuple\\n        # after attrs branch is merged, it will be easier like `.add(t=text)`\\n        my_dict.add([(\"t\", text)])\\n        self.wait()\\n\\n        rect = Rectangle().next_to(text, DOWN)\\n        # can also do key assignment like a python dict\\n        my_dict[\"r\"] = rect\\n\\n        # access submobjects like a python dict\\n        my_dict[\"t\"].set_color(PURPLE)\\n        self.play(my_dict[\"t\"].animate.scale(3))\\n        self.wait()\\n\\n        # also supports python dict styled reassignment\\n        my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)\\n        self.wait()\\n\\n        # remove submobject by key\\n        my_dict.remove(\"t\")\\n        self.wait()\\n\\n        self.play(Uncreate(my_dict[\"s\"]))\\n        self.wait()\\n\\n        self.play(FadeOut(my_dict[\"c\"]))\\n        self.wait()\\n\\n        self.play(FadeOut(my_dict[\"r\"], shift=DOWN))\\n        self.wait()\\n\\n        # you can also make a VDict from an existing dict of mobjects\\n        plain_dict = {\\n            1: Integer(1).shift(DOWN),\\n            2: Integer(2).shift(2 * DOWN),\\n            3: Integer(3).shift(3 * DOWN),\\n        }\\n\\n        vdict_from_plain_dict = VDict(plain_dict)\\n        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))\\n        self.play(Create(vdict_from_plain_dict))\\n\\n        # you can even use zip\\n        vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))\\n        vdict_using_zip.shift(1.5 * RIGHT)\\n        self.play(Create(vdict_using_zip))\\n        self.wait()"
    },
    {
        "text_input": "Generate the code to demonstrate creating circles with varying radii and colors using VGroup in manim, initializing with a list comprehension, and adding them to the scene.\n",
        "output": "from manim import *\\n\\nclass ArcShapeIris(Scene):\\n    def construct(self):\\n        colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]\\n        radius = [1 + rad * 0.1 for rad in range(len(colors))]\\n\\n        circles_group = VGroup()\\n\\n        # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]\\n        circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)\\n                            for rad, col in zip(radius, colors)])\\n        self.add(circles_group)"
    },
    {
        "text_input": "Generate the code to demonstrate creating a line from two points, adding dots at specified proportions along the line with different colors using `point_from_proportion` in manim.\n",
        "output": "from manim import *\\n\\nclass PointFromProportion(Scene):\\n    def construct(self):\\n        line = Line(2*DL, 2*UR)\\n        self.add(line)\\n        colors = (RED, BLUE, YELLOW)\\n        proportions = (1/4, 1/2, 3/4)\\n        for color, proportion in zip(colors, proportions):\\n            self.add(Dot(color=color).move_to(\\n                    line.point_from_proportion(proportion)\\n            ))"
    },
    {
        "text_input": "Create a scene demonstrating two regular pentagons one shifted left and the other shifted right with reversed direction.",
        "output": "from manim import *\\n\\nclass ChangeOfDirection(Scene):\\n    def construct(self):\\n        ccw = RegularPolygon(5)\\n        ccw.shift(LEFT)\\n        cw = RegularPolygon(5)\\n        cw.shift(RIGHT).reverse_direction()\\n\\n        self.play(Create(ccw), Create(cw),\\n        run_time=4)"
    },
    {
        "text_input": "Generate a Manim scene that creates a line from 2*DL to 2*UR and adds dots in colors (RED, BLUE, YELLOW) at proportions (1/4, 1/2, 3/4) along the line.\n",
        "output": "from manim import *\\n\\nclass PointFromProportion(Scene):\\n    def construct(self):\\n        line = Line(2*DL, 2*UR)\\n        self.add(line)\\n        colors = (RED, BLUE, YELLOW)\\n        proportions = (1/4, 1/2, 3/4)\\n        for color, proportion in zip(colors, proportions):\\n            self.add(Dot(color=color).move_to(\\n                    line.point_from_proportion(proportion)\\n            ))"
    },
    {
        "text_input": "Create a Manim scene that animates the creation of two regular polygons, one shifted left and the other shifted right and reversed in direction, both having 5 sides, with a runtime of 4 seconds.\n",
        "output": "from manim import *\\n\\nclass ChangeOfDirection(Scene):\\n    def construct(self):\\n        ccw = RegularPolygon(5)\\n        ccw.shift(LEFT)\\n        cw = RegularPolygon(5)\\n        cw.shift(RIGHT).reverse_direction()\\n\\n        self.play(Create(ccw), Create(cw),\\n        run_time=4)"
    },
    {
        "text_input": "Generate a Manim scene that creates a yellow line from LEFT to RIGHT with a stroke width of 20 and rounded cap style.\n",
        "output": "from manim import *\\n\\nclass CapStyleExample(Scene):\\n    def construct(self):\\n        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\\n        line.set_cap_style(CapStyleType.ROUND)\\n        self.add(line)"
    },
    {
        "text_input": "Create a Manim scene that adds a scaled square filled with white, and three circles filled with green (opacity 0.8), yellow (default opacity), and a custom color (#FF2135) with opacity 0.2, arranged in a group.\n",
        "output": "from manim import *\\n\\nclass SetFill(Scene):\\n    def construct(self):\\n        square = Square().scale(2).set_fill(WHITE,1)\\n        circle1 = Circle().set_fill(GREEN,0.8)\\n        circle2 = Circle().set_fill(YELLOW) # No fill_opacity\\n        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\\n        group = Group(circle1,circle2,circle3).arrange()\\n        self.add(square)\\n        self.add(group)"
    },
    {
        "text_input": "Generate Manim code to create a scene that demonstrates setting points as corners for a VMobject, creating a red square and crosses using specified corner points, and scaling it by a factor of 2.\n",
        "output": "from manim import *\\n\\nclass PointsAsCornersExample(Scene):\\n    def construct(self):\\n        corners = (\\n            # create square\\n            UR, UL,\\n            DL, DR,\\n            UR,\\n            # create crosses\\n            DL, UL,\\n            DR\\n        )\\n        vmob = VMobject(stroke_color=RED)\\n        vmob.set_points_as_corners(corners).scale(2)\\n        self.add(vmob)"
    },
    {
        "text_input": "Generate Manim code to create a scene that demonstrates setting sheen effect on a circle with fill opacity 1, positioned at the bottom-right corner with a sheen factor of -0.3.\n",
        "output": "from manim import *\\n\\nclass SetSheen(Scene):\\n    def construct(self):\\n        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\\n        self.add(circle)"
    },
    {
        "text_input": "Generate Manim code to create a scene that demonstrates updating a DecimalNumber to display the height of a blue Rectangle, with a gray stroke copy of the rectangle added, initially set to 0.5 opacity. The rectangle's height should animate to 5 during the scene.\n",
        "output": "from manim import *\\n\\nclass HeightExample(Scene):\\n    def construct(self):\\n        decimal = DecimalNumber().to_edge(UP)\\n        rect = Rectangle(color=BLUE)\\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\\n\\n        decimal.add_updater(lambda d: d.set_value(rect.height))\\n\\n        self.add(rect_copy, rect, decimal)\\n        self.play(rect.animate.set(height=5))\\n        self.wait()"
    },
    {
        "text_input": "Generate Manim code to create a scene that demonstrates updating a DecimalNumber to display the width of a blue Rectangle, with a gray stroke copy of the rectangle added, initially set to 0.5 opacity. The rectangle's width should animate to 7 during the scene.\n",
        "output": "from manim import *\\n\\nclass WidthExample(Scene):\\n    def construct(self):\\n        decimal = DecimalNumber().to_edge(UP)\\n        rect = Rectangle(color=BLUE)\\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\\n\\n        decimal.add_updater(lambda d: d.set_value(rect.width))\\n\\n        self.add(rect_copy, rect, decimal)\\n        self.play(rect.animate.set(width=7))\\n        self.wait()"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ExampleArrow3D` that includes `ThreeDAxes`, an `Arrow3D` from \\([0, 0, 0]\\) to \\([2, 2, 2]\\) with resolution 8, and set the camera orientation to \\(\\phi = 75\\) degrees and \\(\\theta = 30\\) degrees.",
        "output": "from manim import *\\n\\nclass ExampleArrow3D(ThreeDScene):\\n    def construct(self):\\n        axes = ThreeDAxes()\\n        arrow = Arrow3D(\\n            start=np.array([0, 0, 0]),\\n            end=np.array([2, 2, 2]),\\n            resolution=8\\n        )\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        self.add(axes, arrow)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ExampleCone` that includes `ThreeDAxes`, a `Cone` with direction \\([1, 1, 2]\\) and resolution 8, and set the camera orientation to \\(\\phi = \\frac{5\\pi}{11}\\) and \\(\\theta = \\frac{\\pi}{9}\\).",
        "output": "from manim import *\\n\\nclass ExampleCone(ThreeDScene):\\ndef construct(self):\\naxes = ThreeDAxes()\\ncone = Cone(direction=X_AXIS+Y_AXIS+2Z_AXIS, resolution=8)\\nself.set_camera_orientation(phi=5PI/11, theta=PI/9)\\nself.add(axes, cone)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `CubeExample` that includes `ThreeDAxes`, a `Cube` with side length 3, fill opacity 0.7, and fill color blue, and set the camera orientation to \\(\\phi = 75\\) degrees and \\(\\theta = -45\\) degrees.",
        "output": "from manim import *\\n\\nclass CubeExample(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\\n\\n        axes = ThreeDAxes()\\n        cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)\\n        self.add(cube)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ExampleCylinder` that includes `ThreeDAxes`, a `Cylinder` with radius 2 and height 3, and set the camera orientation to \\(\\phi = 75\\) degrees and \\(\\theta = 30\\) degrees.",
        "output": "from manim import *\\n\\nclass ExampleCylinder(ThreeDScene):\\n    def construct(self):\\n        axes = ThreeDAxes()\\n        cylinder = Cylinder(radius=2, height=3)\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        self.add(axes, cylinder)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `Dot3DExample` that includes `ThreeDAxes`, and three `Dot3D` objects: `dot_1` at (0, 0, 1) in red, `dot_2` at (2, 0, 0) in blue with radius 0.1, and `dot_3` at [0, 0, 0] in orange with radius 0.1, setting the camera orientation to \\(\\phi = 75\\) degrees and \\(\\theta = -45\\) degrees.",
        "output": "from manim import *\\n\\nclass Dot3DExample(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\\n\\n        axes = ThreeDAxes()\\n        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)\\n        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)\\n        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)\\n        self.add(axes, dot_1, dot_2,dot_3)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ExampleLine3D` that includes `ThreeDAxes`, and a `Line3D` object `line` that starts at \\([0, 0, 0]\\) and ends at \\([2, 2, 2]\\). Set the camera orientation to \\(\\phi = 75\\) degrees and \\(\\theta = 30\\) degrees.",
        "output": "from manim import *\\n\\nclass ExampleLine3D(ThreeDScene):\\n    def construct(self):\\n        axes = ThreeDAxes()\\n        line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        self.add(axes, line)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ParallelLineExample` that includes `ThreeDAxes`, and two `Line3D` objects: `line1` starting at \\([2, 1, 1]\\) in red, and `line2` parallel to `line1` in yellow, setting the camera orientation to \\(\\phi = \\frac{\\pi}{3}\\) and \\(\\theta = -\\frac{\\pi}{4}\\).",
        "output": "from manim import *\\n\\nclass ParallelLineExample(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(PI / 3, -PI / 4)\\n        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\\n        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\\n        line2 = Line3D.parallel_to(line1, color=YELLOW)\\n        self.add(ax, line1, line2)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ExamplePrism` that includes `ThreeDAxes`, and two `Prism` objects: `prismSmall` with dimensions [1, 2, 3] rotated by \\(\\frac{\\pi}{2}\\), and `prismLarge` with dimensions [1.5, 3, 4.5] moved to [2, 0, 0], setting the camera orientation to \\(\\phi = 60\\) degrees and \\(\\theta = 150\\) degrees.",
        "output": "from manim import *\\n\\nclass ExamplePrism(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)\\n        prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)\\n        prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])\\n        self.add(prismSmall, prismLarge)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ExampleSphere` that includes `ThreeDAxes`, and three `Sphere` objects: `sphere1` in red at (3, 0, 0) with radius 1, `sphere2` in green at (-1, -3, 0) with radius 2, and `sphere3` in blue at (-1, 2, 0) with radius 2, setting the camera orientation to \\(\\phi = \\frac{\\pi}{6}\\) and \\(\\theta = \\frac{\\pi}{6}\\).",
        "output": "from manim import *\\n\\nclass ExampleSphere(ThreeDScene):\\n    def construct(self):\\n        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)\\n        sphere1 = Sphere(\\n            center=(3, 0, 0),\\n            radius=1,\\n            resolution=(20, 20),\\n            u_range=[0.001, PI - 0.001],\\n            v_range=[0, TAU]\\n        )\\n        sphere1.set_color(RED)\\n        self.add(sphere1)\\n        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))\\n        sphere2.set_color(GREEN)\\n        self.add(sphere2)\\n        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))\\n        sphere3.set_color(BLUE)\\n        self.add(sphere3)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `FillByValueExample` that includes `ThreeDAxes` with x range (0, 5, 1), y range (0, 5, 1), and z range (-1, 1, 0.5), and a `Surface` object `surface_plane` filled with a color scale based on the z-axis values of the parametric surface \\( z = \\sin(x) \\cdot \\cos(y) \\). Set the camera orientation to \\(\\phi = 75\\) degrees and \\(\\theta = -160\\) degrees.",
        "output": "from manim import *\\n\\nclass FillByValueExample(ThreeDScene):\\n    def construct(self):\\n        resolution_fa = 8\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)\\n        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))\\n        def param_surface(u, v):\\n            x = u\\n            y = v\\n            z = np.sin(x) * np.cos(y)\\n            return z\\n        surface_plane = Surface(\\n            lambda u, v: axes.c2p(u, v, param_surface(u, v)),\\n            resolution=(resolution_fa, resolution_fa),\\n            v_range=[0, 5],\\n            u_range=[0, 5],\\n            )\\n        surface_plane.set_style(fill_opacity=1)\\n        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)\\n        self.add(axes, surface_plane)"
    },
    {
        "text_input": "Create a 3D scene in Manim named `ExampleTorus` that includes `ThreeDAxes`, and a `Torus` object. Set the camera orientation to \\(\\phi = 75\\) degrees and \\(\\theta = 30\\) degrees.",
        "output": "from manim import *\\n\\nclass ExampleTorus(ThreeDScene):\\n    def construct(self):\\n        axes = ThreeDAxes()\\n        torus = Torus()\\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\\n        self.add(axes, torus)"
    },
    {
        "text_input": "Create a scene in Manim named `ComplexValueTrackerExample` that includes a `NumberPlane` and a `Dot` object `dot` that updates its position to the complex value tracked by `ComplexValueTracker` `tracker`. Initially, `tracker` is set to -2+1j. The scene then plays animations to set `tracker` to 3+2j, then to its current value multiplied by 1j, then to its current value minus 2j, and finally to its current value divided by (-2+3j).",
        "output": "from manim import *\\n\\nclass ComplexValueTrackerExample(Scene):\\n    def construct(self):\\n        tracker = ComplexValueTracker(-2+1j)\\n        dot = Dot().add_updater(\\n            lambda x: x.move_to(tracker.points)\\n        )\\n\\n        self.add(NumberPlane(), dot)\\n\\n        self.play(tracker.animate.set_value(3+2j))\\n        self.play(tracker.animate.set_value(tracker.get_value() * 1j))\\n        self.play(tracker.animate.set_value(tracker.get_value() - 2j))\\n        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))"
    },
    {
        "text_input": "Create a scene in Manim named `ValueTrackerExample` that includes a `NumberLine`, a `Vector` `pointer` pointing downward, and a `MathTex` label \"x\" attached to the pointer and updating its position. Additionally, create a `ValueTracker` `tracker` initialized to 0, which updates the position of the pointer along the number line. The scene then demonstrates the tracker's functionality by incrementing and decrementing its value, setting its value to 5, setting its value to 3, and then incrementing its value by -2.",
        "output": "from manim import *\\n\\nclass ValueTrackerExample(Scene):\\n    def construct(self):\\n        number_line = NumberLine()\\n        pointer = Vector(DOWN)\\n        label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\\n\\n        tracker = ValueTracker(0)\\n        pointer.add_updater(\\n            lambda m: m.next_to(\\n                        number_line.n2p(tracker.get_value()),\\n                        UP\\n                    )\\n        )\\n        self.add(number_line, pointer,label)\\n        tracker += 1.5\\n        self.wait(1)\\n        tracker -= 4\\n        self.wait(0.5)\\n        self.play(tracker.animate.set_value(5))\\n        self.wait(0.5)\\n        self.play(tracker.animate.set_value(3))\\n        self.play(tracker.animate.increment_value(-2))\\n        self.wait(0.5)"
    },
    {
        "text_input": "Create a scene in Manim named `ValueTrackerExample` that includes a `Dot` object `label` with a radius of 3, and a `ValueTracker` object `tracker` initialized to 0. The position of the label is updated to match the value of the tracker along the x-axis. The tracker also continuously increments its value over time.",
        "output": "from manim import *\\n\\nclass ValueTrackerExample(Scene):\\n    def construct(self):\\n        tracker = ValueTracker(0)\\n        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))\\n        self.add(label)\\n        self.add(tracker)\\n        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))\\n        self.wait(2)"
    },
    {
        "text_input": "Create a scene in Manim named `BasicUsage` that includes an `ArrowVectorField` object representing a vector field defined by the lambda function `func`. The function scales each position vector \\((x, y)\\) by \\(\\frac{1}{3}\\) and subtracts the original vector from the scaled vector.",
        "output": "from manim import *\\n\\nclass BasicUsage(Scene):\\n    def construct(self):\\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\\n        self.add(ArrowVectorField(func))"
    },
    {
        "text_input": "Create a scene in Manim named `SizingAndSpacing` that includes an `ArrowVectorField` object `vf` representing a vector field defined by a lambda function `func` with a sinusoidal and cosine component, and another `ArrowVectorField` object `vf2` with the same definition as `vf` but with vectors scaled by a factor of 1/3, animating `vf` to become `vf2`.",
        "output": "from manim import *\\n\\nclass SizingAndSpacing(Scene):\\n    def construct(self):\\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\\n        vf = ArrowVectorField(func, x_range=[-7, 7, 1])\\n        self.add(vf)\\n        self.wait()\\n\\n        length_func = lambda x: x / 3\\n        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)\\n        self.play(vf.animate.become(vf2))\\n        self.wait()"
    },
    {
        "text_input": "Create a scene in Manim named `Coloring` that includes an `ArrowVectorField` object `vf` representing a vector field defined by the lambda function `func` that shifts the position vector by \\(-5\\) units along the x-axis. The vector field is colored based on the `colors` list, with a minimum color scheme value of 2 and a maximum color scheme value of 10. Additionally, display two circles `min_radius` and `max_radius` with radii 2 and 10 respectively, colored according to the first and last colors in the `colors` list, both shifted by \\(-5\\) units along the x-axis.",
        "output": "from manim import *\\n\\nclass Coloring(Scene):\\n    def construct(self):\\n        func = lambda pos: pos - LEFT * 5\\n        colors = [RED, YELLOW, BLUE, DARK_GRAY]\\n        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)\\n        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)\\n        vf = ArrowVectorField(\\n            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors\\n        )\\n        self.add(vf, min_radius, max_radius)"
    },
    {
        "text_input": "Create a scene in Manim named `BasicUsage` that includes `StreamLines` object representing streamlines of a vector field defined by the lambda function `func`. The function scales each position vector \\((x, y)\\) by \\(\\frac{1}{3}\\) and subtracts the original vector from the scaled vector.",
        "output": "from manim import *\\n\\nclass BasicUsage(Scene):\\n    def construct(self):\\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\\n        self.add(StreamLines(func))"
    },
    {
        "text_input": "Create a scene in Manim named `SpawningAndFlowingArea` that includes a `StreamLines` object `stream_lines` representing streamlines of a vector field defined by the lambda function `func`, a `Rectangle` object `spawning_area` with width 6 and height 4, and a `Rectangle` object `flowing_area` with width 8 and height 6. Additionally, add two labels, \"Spawning Area\" and \"Flowing Area\", with background rectangles behind them for better visibility.",
        "output": "from manim import *\\n\\nclass SpawningAndFlowingArea(Scene):\\n    def construct(self):\\n        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5\\n        stream_lines = StreamLines(\\n            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1\\n        )\\n\\n        spawning_area = Rectangle(width=6, height=4)\\n        flowing_area = Rectangle(width=8, height=6)\\n        labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]\\n        for lbl in labels:\\n            lbl.add_background_rectangle(opacity=0.6, buff=0.05)\\n\\n        self.add(stream_lines, spawning_area, flowing_area, *labels)"
    },
    {
        "text_input": "Create a scene in Manim named `StreamLineCreation` that includes a `StreamLines` object `stream_lines` representing streamlines of a vector field defined by the lambda function `func`, with a yellow color, stroke width of 3, and using virtual time for faster animation. The streamlines are created using the `create()` method and then displayed using the `play()` method.",
        "output": "from manim import *\\n\\nclass StreamLineCreation(Scene):\\n    def construct(self):\\n        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos\\n        stream_lines = StreamLines(\\n            func,\\n            color=YELLOW,\\n            x_range=[-7, 7, 1],\\n            y_range=[-4, 4, 1],\\n            stroke_width=3,\\n            virtual_time=1,  # use shorter lines\\n            max_anchors_per_line=5,  # better performance with fewer anchors\\n        )\\n        self.play(stream_lines.create())  # uses virtual_time as run_time\\n        self.wait()"
    },
    {
        "text_input": "Create a scene in Manim named `EndAnimation` that includes a `StreamLines` object `stream_lines` representing streamlines of a vector field defined by the lambda function `func`, with a blue color, stroke width of 3, and using virtual time for faster animation. The streamlines are initially added to the scene, then the animation is started with specific parameters, and finally, the animation is ended after waiting for 1 second.",
        "output": "from manim import *\\n\\nclass EndAnimation(Scene):\\n    def construct(self):\\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\\n        stream_lines = StreamLines(\\n            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\\n        )\\n        self.add(stream_lines)\\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\\n        self.wait(1)\\n        self.play(stream_lines.end_animation())"
    },
    {
        "text_input": "Create a scene in Manim named `ContinuousMotion` that includes a `StreamLines` object `stream_lines` representing streamlines of a vector field defined by the lambda function `func`, with a stroke width of 3 and maximum anchors per line set to 30. The streamlines are added to the scene, then the animation is started with specific parameters, and the scene waits for the duration of the animation to complete based on the virtual time and flow speed of the streamlines.",
        "output": "from manim import *\\n\\nclass ContinuousMotion(Scene):\\n    def construct(self):\\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\\n        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)\\n        self.add(stream_lines)\\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5)\\n        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)"
    },
    {
        "text_input": "Create a scene in Manim named `Nudging` that includes an `ArrowVectorField` object `vector_field` representing a vector field defined by the lambda function `func`, with streamlines nudging a circle and a dot. The circle and dot are initially displayed, and then the `nudge` method is used to animate the movement of the circle and dot along the streamlines. The scene waits for 6 seconds to observe the animation.",
        "output": "from manim import *\\n\\nclass Nudging(Scene):\\n    def construct(self):\\n        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP\\n        vector_field = ArrowVectorField(\\n            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2\\n        )\\n        self.add(vector_field)\\n        circle = Circle(radius=2).shift(LEFT)\\n        self.add(circle.copy().set_color(GRAY))\\n        dot = Dot().move_to(circle)\\n\\n        vector_field.nudge(circle, -2, 60, True)\\n        vector_field.nudge(dot, -2, 60)\\n\\n        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))\\n        dot.add_updater(vector_field.get_nudge_updater())\\n        self.add(circle, dot)\\n        self.wait(6)"
    },
    {
        "text_input": "Create a scene in Manim named `ScaleVectorFieldFunction` that includes an `ArrowVectorField` object `vector_field` representing a vector field defined by the lambda function `func`, with streamlines. Initially, the vector field is displayed, then the function `scale_func` is used to scale the vector field function by a factor of 0.5, and finally, the vector field is animated to become the scaled vector field. The scene waits for a moment to observe the animation.",
        "output": "from manim import *\\n\\nclass ScaleVectorFieldFunction(Scene):\\n    def construct(self):\\n        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP\\n        vector_field = ArrowVectorField(func)\\n        self.add(vector_field)\\n        self.wait()\\n\\n        func = VectorField.scale_func(func, 0.5)\\n        self.play(vector_field.animate.become(ArrowVectorField(func)))\\n        self.wait()"
    },






	

	{
        "text_input": "Create a scene with four arcs of different sizes and colors, each with a brace. Arrange these arcs in a grid.",
        "output": "from manim import \n\nclass ArcBraceExample(Scene):\n def construct(self):\n arc_1 = Arc(radius=1.5,start_angle=0,angle=2PI/3).set_color(RED)\n brace_1 = ArcBrace(arc_1,LEFT)\n group_1 = VGroup(arc_1,brace_1)\n\n arc_2 = Arc(radius=3,start_angle=0,angle=5PI/6).set_color(YELLOW)\n brace_2 = ArcBrace(arc_2)\n group_2 = VGroup(arc_2,brace_2)\n\n arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)\n brace_3 = ArcBrace(arc_3)\n group_3 = VGroup(arc_3,brace_3)\n\n arc_4 = Arc(radius=0.2,start_angle=0,angle=3PI/2).set_color(GREEN)\n brace_4 = ArcBrace(arc_4)\n group_4 = VGroup(arc_4,brace_4)\n\n arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)\n self.add(arc_group.center())"
    },
    {
        "text_input": "Create a scene with a square and four braces with varying sharpness values. Add text labels indicating the sharpness values next to each brace and arrange them vertically.",
        "output": "from manim import *\n\nclass BraceExample(Scene):\n def construct(self):\n s = Square()\n self.add(s)\n for i in np.linspace(0.1,1.0,4):\n br = Brace(s, sharpness=i)\n t = Text(f\"sharpness= {i}\").next_to(br, RIGHT)\n self.add(t)\n self.add(br)\n VGroup(*self.mobjects).arrange(DOWN, buff=0.2)"
    },
    {
        "text_input": "Create a scene with a brace between two points and a number plane in the background. Animate the creation of both the number plane and the brace.",
        "output": "from manim import *\n\nclass BraceBPExample(Scene):\n def construct(self):\n p1 = [0,0,0]\n p2 = [1,2,0]\n brace = BraceBetweenPoints(p1,p2)\n self.play(Create(NumberPlane()))\n self.play(Create(brace))\n self.wait(2)"
    },
    {
        "text_input": "Create a scene with a decimal table displaying the values of a function f(x) = e^x for x in [-2, -1, 0, 1, 2]. The table should have labels for the rows and display numbers with two decimal places.",
        "output": "from manim import *\n\nclass DecimalTableExample(Scene):\n def construct(self):\n x_vals = [-2,-1,0,1,2]\n y_vals = np.exp(x_vals)\n t0 = DecimalTable(\n [x_vals, y_vals],\n row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n h_buff=1,\n element_to_mobject_config={\"num_decimal_places\": 2})\n self.add(t0)"
    },
    {
        "text_input": "Create a scene with an integer table displaying values of sine and cosine functions for specific angles. Label the columns with the corresponding square root fractions and rows with sine and cosine. Display units in degrees.",
        "output": "from manim import *\n\nclass IntegerTableExample(Scene):\n def construct(self):\n t0 = IntegerTable(\n [[0,30,45,60,90],\n [90,60,45,30,0]],\n col_labels=[\n MathTex(\"\\frac{\\sqrt{0}}{2}\"),\n MathTex(\"\\frac{\\sqrt{1}}{2}\"),\n MathTex(\"\\frac{\\sqrt{2}}{2}\"),\n MathTex(\"\\frac{\\sqrt{3}}{2}\"),\n MathTex(\"\\frac{\\sqrt{4}}{2}\")],\n row_labels=[MathTex(\"\\sin\"), MathTex(\"\\cos\")],\n h_buff=1,\n element_to_mobject_config={\"unit\": \"^{\\circ}\"})\n self.add(t0)"
    },
    {
        "text_input": "Create a scene with a mathematical table including outer lines. The table should have a header row and column with arithmetic values.",
        "output": "from manim import *\n\nclass MathTableExample(Scene):\n def construct(self):\n t0 = MathTable(\n [[\"+\", 0, 5, 10],\n [0, 0, 5, 10],\n [2, 2, 7, 12],\n [4, 4, 9, 14]],\n include_outer_lines=True)\n self.add(t0)"
    },
    {
        "text_input": "Create a scene with a table of Mobjects including red circles and blue crosses arranged in a 3x3 grid. Draw a red diagonal line from the bottom-left to the top-right corner of the table.",
        "output": "from manim import *\n\nclass MobjectTableExample(Scene):\n def construct(self):\n cross = VGroup(\n Line(UP + LEFT, DOWN + RIGHT),\n Line(UP + RIGHT, DOWN + LEFT),\n )\n a = Circle().set_color(RED).scale(0.5)\n b = cross.set_color(BLUE).scale(0.5)\n t0 = MobjectTable(\n [[a.copy(),b.copy(),a.copy()],\n [b.copy(),a.copy(),a.copy()],\n [a.copy(),b.copy(),b.copy()]]\n )\n line = Line(\n t0.get_corner(DL), t0.get_corner(UR)\n ).set_color(RED)\n self.add(t0, line)"
    },
    {
        "text_input": "Create a scene with four different table examples demonstrating various features of tables in Manim, such as labels, highlighted cells, outer lines, and customized top-left entries. Arrange these tables in a grid.",
        "output": "from manim import *\n\nclass TableExamples(Scene):\n    def construct(self):\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table in \\n Manim.\"]])\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        t1.add_highlighted_cell((2,2), color=YELLOW)\n        t2 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            arrange_in_grid_config={\"cell_alignment\": RIGHT})\n        t2.add(t2.get_cell((2,2), color=RED))\n        t3 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            line_config={\"stroke_width\": 1, \"color\": YELLOW})\n        t3.remove(*t3.get_vertical_lines())\n        g = Group(\n            t0,t1,t2,t3\n        ).scale(0.7).arrange_in_grid(buff=1)\n        self.add(g)"
    },
    {
        "text_input": "Create a scene with a background rectangle filled with a gradient color. Include two tables with background rectangles for entries, one with background rectangles for each entry and the other with a single background rectangle. Arrange these tables in a group.",
        "output": "from manim import *\n\nclass BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background = Rectangle(height=6.5, width=13)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            add_background_rectangles_to_entries=True)\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            include_background_rectangle=True)\n        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)\n        self.add(g)"
    },
    {
        "text_input": "Create a scene with a table labeled with rows and columns. Highlight the cell at the intersection of the second row and second column in green.",
        "output": "from manim import *\n\nclass AddHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add_highlighted_cell((2,2), color=GREEN)\n        self.add(table)"
    },
    {
        "text_input": "Create a scene with a table consisting of specified rows and columns along with row and column labels in manim.",
        "output": "from manim import *\n\nclass CreateTableExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            include_outer_lines=True)\n        self.play(table.create())\n        self.wait()"
    },
    {
        "text_input": "Create a scene with a table and highlight a specific cell in manim.",
        "output": "from manim import *\nclass GetCellExample(Scene):\n def construct(self):\n table = Table(\n [[\"First\", \"Second\"],\n [\"Third\",\"Fourth\"]],\n row_labels=[Text(\"R1\"), Text(\"R2\")],\n col_labels=[Text(\"C1\"), Text(\"C2\")])\n cell = table.get_cell((2,2), color=RED)\n self.add(table, cell)\n"
    },
    {
        "text_input": "Generate code to create a table with row and column labels and randomly color the column labels in manim.",
        "output" : "from manim import *\n\nclass GetColLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_col_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table)"
    }
		
		
		
		
			
		
	
				
			
		
		
		
		
				
			
		
				
			
		
			
				
			
		
			
		
		
		
		
		
		
		
	
	
	
	
	
	
	
	]
	